<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>优化gradle编译</title>
      <link href="/2021/11/29/you-hua-gradle-bian-yi/"/>
      <url>/2021/11/29/you-hua-gradle-bian-yi/</url>
      
        <content type="html"><![CDATA[<p>title: 去掉gradle编译的测试<br>date: 2021-11-29 20:24:30<br>tags:</p><ul><li>android</li><li>gradle</li><li>优化</li></ul><h3 id="去掉gradle编译的测试相关内容"><a href="#去掉gradle编译的测试相关内容" class="headerlink" title="去掉gradle编译的测试相关内容"></a>去掉gradle编译的测试相关内容</h3><pre class=" language-gradle"><code class="language-gradle">tasks.withType(Test){    reports.html.setEnabled(false)    reports.junitXml.setEnabled(false)}tasks.withType(JavaCompile){    options.setFork(true)    options.setIncremental(true)}</code></pre>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>魔趣源代码下载</title>
      <link href="/2020/04/30/mo-qu-yuan-dai-ma-xia-zai/"/>
      <url>/2020/04/30/mo-qu-yuan-dai-ma-xia-zai/</url>
      
        <content type="html"><![CDATA[<p>title:魔趣系统源代码下载<br>date: 2020-04-30 147:07:27<br>tags: </p><ul><li>Android</li><li>系统</li><li>源代码</li><li>编译</li></ul><h2 id="魔趣源代码下载"><a href="#魔趣源代码下载" class="headerlink" title="魔趣源代码下载"></a>魔趣源代码下载</h2><h5 id="搞魔趣源代码原因"><a href="#搞魔趣源代码原因" class="headerlink" title="搞魔趣源代码原因"></a>搞魔趣源代码原因</h5><pre><code>最近一直在研究干掉钉钉之类的打卡程序定位什么的,我对hook等方式一直觉得不够好,原因是容易被检测出来,所以一直想搞一个有源代码的手机系统.但是无奈我没有pixel系列手机设备,主要是太贵.我手里呢,又只有小米的低端系列红米手机(三部),奈何小米不开源,但是我无意中知道了魔趣这个系统便开始了我的折腾之旅.一开始就遇到了无法下载源代码的问题,奈何我不是翻墙党,还不是因为穷.经过研究和摸索,终于让我找到了可以不用翻墙获取源代码的方式.特意记录一下.</code></pre><h3 id="开始我们的源代码下载"><a href="#开始我们的源代码下载" class="headerlink" title="开始我们的源代码下载"></a>开始我们的源代码下载</h3><h5 id="1-先下载repo文件"><a href="#1-先下载repo文件" class="headerlink" title="1.先下载repo文件"></a>1.先下载repo文件</h5><pre><code>https://raw.githubusercontent.com/MoKee/git-repo/stable/repo可以使用下载工具,先将魔趣的repo文件下载到本地,也可以用浏览器打开,然后复制页面的所有内容到本地的文本文件内.记得去掉扩展名,保存问repo即可然后我们修改repo文件的属性,加入执行权限sudo chmod +x repo然后留着备用</code></pre><h5 id="2-获取清华git-repo"><a href="#2-获取清华git-repo" class="headerlink" title="2.获取清华git-repo"></a>2.获取清华git-repo</h5><pre><code>我们先要使用git获取一下git-repo仓库内容,这个是在清华,所以直接checkgit clone https://mirrors.tuna.tsinghua.edu.cn/git/git-repo下载之后,我们可以得到一个文件夹,git-repo,首先我们把git-repo改名为repo备用</code></pre><h5 id="3-建立源代码文件夹"><a href="#3-建立源代码文件夹" class="headerlink" title="3.建立源代码文件夹"></a>3.建立源代码文件夹</h5><pre><code>新建SourceCode文件夹,把repo文件复制到里面.建立.repo文件夹,注意前面有&quot;.&quot;然后把我们改名字的repo文件夹,注意是文件夹,复制到.repo目录里面.</code></pre><h5 id="4-初始化repo"><a href="#4-初始化repo" class="headerlink" title="4.初始化repo"></a>4.初始化repo</h5><pre><code>完成上面三步工作以后,我们可以正式的初始化仓库了.我们需要在当前的SourceCode目录内执行如下命令,其中mkp是9.0系统,如果你需要下载10.0,那么找对应的分支就可以了,魔趣官网可查../repo init -u https://github.com/MoKee/android -b mkp等待仓库初始化完成.</code></pre><h5 id="5-修改-repo文件夹配置文件"><a href="#5-修改-repo文件夹配置文件" class="headerlink" title="5.修改.repo文件夹配置文件"></a>5.修改.repo文件夹配置文件</h5><pre><code>仓库初始化完成,我们需要进入.repo文件夹内,找到manifest.xml文件,看看它里面的内容是否如下&lt;manifest&gt;&lt;include name=&quot;default.xml&quot;/&gt;&lt;/manifest&gt;如果是如下,我们就需要进入..repo/manifests文件夹内,找到default.xml文件并打开它&lt;manifest&gt;   &lt;remote  name=&quot;aosp&quot;-           fetch=&quot;https://android.googlesource.com&quot;+           fetch=&quot;https://aosp.tuna.tsinghua.edu.cn&quot;            review=&quot;android-review.googlesource.com&quot; /&gt;   &lt;remote  name=&quot;github&quot;找到fetch=&quot;https://android.googlesource.com&quot;,修改为fetch=&quot;https://aosp.tuna.tsinghua.edu.cn&quot;这样我们就使用aosp清华源来进行更新了.</code></pre><h5 id="6-下载代码"><a href="#6-下载代码" class="headerlink" title="6.下载代码"></a>6.下载代码</h5><pre><code>接着我们就可以进行代码同步了./repo sync</code></pre><h4 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h4><p>经过漫长的等待,源代码就可以下载完成了.如果中途有断线,那就继续执行一下./repo sync,慢慢的同步. 直到代码都下载完成.</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>在Ubuntu下面解压缩分卷的Android系统源代码</title>
      <link href="/2020/02/29/zai-ubuntu-xia-mian-jie-ya-suo-fen-juan-de-android-xi-tong-yuan-dai-ma/"/>
      <url>/2020/02/29/zai-ubuntu-xia-mian-jie-ya-suo-fen-juan-de-android-xi-tong-yuan-dai-ma/</url>
      
        <content type="html"><![CDATA[<hr><p>title: 在Ubuntu下面解压缩分卷的Android系统源代码并编译<br>date: 2020-02-29 21:10:11<br>tags: </p><ul><li>android</li><li>zip压缩分卷</li><li>系统源代码</li></ul><hr><h3 id="在Ubuntu下面解压缩分卷的Android系统源代码"><a href="#在Ubuntu下面解压缩分卷的Android系统源代码" class="headerlink" title="在Ubuntu下面解压缩分卷的Android系统源代码"></a>在Ubuntu下面解压缩分卷的Android系统源代码</h3><p>最近在翻阅Android系统底层代码，本来打算解压缩到一个ntfs分区，遇到了一些问题，特意记录下来，防止再次犯错</p><h5 id="1-解压缩分卷"><a href="#1-解压缩分卷" class="headerlink" title="1.解压缩分卷"></a>1.解压缩分卷</h5><p>我拿到手里的代码是一个高通8909的系统代码，而且我有对应的硬件，所以研究这个代码，我可以刷机，测试各种我对系统的修改。自然看这份代码比直接查看google的官方代码更有好处。</p><p>但是当我拿到这份代码的时候，在linux下面却无法打开，主要的原因是这个压缩包有29G之多，为了方便网络传输，特意被打包分卷上传到了百度云，我下载之后拿到手里的是差不多31个单独的分卷文件。</p><p>在linux下面，我解压的时候直接提示错误，提示的问题是不识别这个文件是zip文件。</p><p>百度一番之后发现是因为分卷之后每个卷的数据被拆分了，单独解压每一个卷是不行的，必须下把分卷合并起来。合并的命令也很简单，cat命令。</p><p>每个卷的名字大概的样子是androidcode.zip.001 …….androidcode.zip.031这样的一个文件序列，果断使用通配符进行合并</p><pre class=" language-powershell"><code class="language-powershell"><span class="token function">cat</span> androidcode<span class="token punctuation">.</span>zip<span class="token punctuation">.</span><span class="token operator">*</span> > androidcode<span class="token punctuation">.</span>zip</code></pre><p>经过几分钟的等待，这个文件合并完成，我们拿到了androidcode.zip,这回直接可以使用unzip解压缩了。</p><h5 id="2-解压缩源代码的问题"><a href="#2-解压缩源代码的问题" class="headerlink" title="2.解压缩源代码的问题"></a>2.解压缩源代码的问题</h5><p>当解压缩的时候，又出现了新的问题，在解压缩的时候提示文件重名，是否覆盖？可是我这代码里面怎么可能有同名的文件呢？</p><p>经过查找，发现，还真的有，只不过我编译用的分区是使用的Windows的NTFS分区，因为这个机器是一开始配置的Win10系统，但是对我来说完全没用，我就干掉了Win10系统盘，在SSD上面安装了Ubuntu，但是这个机器的普通硬盘还有两个分区，当时懒得管反正linux也能用，就再也没进行分区。我们知道Windows是不区分大小写的，但是Ext4分区是区分大小写的。这就导致了我们在解压缩文件的时候，同一个文件夹下面有大小写不同的两个文件，可是解压到NTFS分区的时候就变成同一个文件了，提示覆盖。问题原因找到了，那就动手把里面的数据复制到另外的磁盘，格式化分区为EXT4，然后再次解压缩，完美！！！</p><h5 id="3-编译系统源代码前的准备工作"><a href="#3-编译系统源代码前的准备工作" class="headerlink" title="3.编译系统源代码前的准备工作"></a>3.编译系统源代码前的准备工作</h5><pre class=" language-shell"><code class="language-shell">#先安装openjdk,安装jdk8就可以了，其他版本最好不要使用sudo apt-get install openjdk-8-jdk#下面是安装编译所必须的库，这些库是有些名字可能有写出入，主要是开发库版本可能有变sudo apt-get install libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dev git flex bison gperf build-essential libncurses5-dev:i386 tofrodos python-markdown xsltproc zlib1g-dev:i386 dpkg-dev libsdl1.2-dev libesd0-dev zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 lib32ncurses5-dev x11proto-core-dev libx11-dev libxml2-utils unzip m4</code></pre><pre class=" language-shell"><code class="language-shell">#进入Android源代码目录，然后开始我们的编译过程source build/envsetup.shlunch msm8909-userdebug make -j8</code></pre><p>刚编译没超过5分钟，立刻出现问题了</p><pre class=" language-shell"><code class="language-shell"> ninja: build stopped: subcommand failed ninja failed with: exit status 1</code></pre><p>看到这个问题，我也是百度google了一大圈，依然有问题，最后发现只要执行一下下面的命令就可以解决问题了,LC_ALL=C 是为了去除所有本地化的设置，让命令能正确执行。</p><pre class=" language-shell"><code class="language-shell">export LC_ALL=C</code></pre><p>经过一个多小时的编译，顺利完成。</p><p>目前来看编译的问题不多，主要是一些前期准备工作太多坑。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>使用ndk创建Android系统内的可执行程序</title>
      <link href="/2020/02/29/shi-yong-ndk-chuang-jian-android-xi-tong-nei-de-ke-zhi-xing-cheng-xu/"/>
      <url>/2020/02/29/shi-yong-ndk-chuang-jian-android-xi-tong-nei-de-ke-zhi-xing-cheng-xu/</url>
      
        <content type="html"><![CDATA[<hr><p>title: 使用ndk创建Android系统内的可执行程序<br>date: 2020-02-29 21:08:20<br>tags: </p><ul><li>android</li><li>linux可执行文件</li><li>arm</li><li>C语言</li></ul><hr><h3 id="使用ndk创建Android系统内的可执行程序"><a href="#使用ndk创建Android系统内的可执行程序" class="headerlink" title="使用ndk创建Android系统内的可执行程序"></a>使用ndk创建Android系统内的可执行程序</h3><p>我们在用ndk的时候大多数是创建的so文件,然后在java层调用.但是今天我们要编写的是直接可以在Android系统上面执行的文件,也就是arm版本的elf文件</p><p>首先新建一个目录</p><p>我们就简单的写一个demo,目录的名字我就叫Calc,因为我们要用c写一个简单的计算器程序.</p><p>然后我们在Calc目录下面在建立一个jni目录</p><p>新建一个文件,Android.mk文件,内容如下</p><pre class=" language-makefile"><code class="language-makefile">LOCAL_PATH <span class="token operator">:=</span> <span class="token variable">$</span><span class="token punctuation">(</span><span class="token keyword">call</span> my-dir<span class="token punctuation">)</span><span class="token keyword">include</span> <span class="token variable">$</span><span class="token punctuation">(</span>CALEAR_VARS<span class="token punctuation">)</span>LOCAL_ARM_MODULE <span class="token operator">:=</span> armLOCAL_MODULE <span class="token operator">:=</span>calcLOCAL_MODULE_FILENAME <span class="token operator">:=</span> calcLOCAL_SRC_FILES <span class="token operator">:=</span> main.c<span class="token keyword">include</span> <span class="token variable">$</span><span class="token punctuation">(</span>BUILD_EXECUTABLE<span class="token punctuation">)</span></code></pre><p>新建Application.mk文件,内容如下</p><pre class=" language-makefile"><code class="language-makefile">APP_PLATFORM <span class="token operator">:=</span> android-16APP_ALLOW_MISSING_DEPS<span class="token operator">=</span>true</code></pre><p>因为上面的内容都是mk文件的基本设置,这里没什么好说的.</p><p>然后建立我们的main.c文件,内容如下</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">sub</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x <span class="token operator">-</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">mul</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">div</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> <span class="token keyword">int</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> x <span class="token operator">/</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">,</span> y<span class="token punctuation">;</span>    <span class="token keyword">int</span> num<span class="token punctuation">;</span>    <span class="token keyword">int</span> rel <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">do</span> <span class="token punctuation">{</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入第一个操作数: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请选择[ 1.+ 2.- 3.* 4./] :"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"请输入第二个操作数: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>num<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">case</span> <span class="token number">1</span><span class="token punctuation">:</span> <span class="token punctuation">{</span>                rel <span class="token operator">=</span> <span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">2</span><span class="token punctuation">:</span><span class="token punctuation">{</span>                rel <span class="token operator">=</span> <span class="token function">sub</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">3</span><span class="token punctuation">:</span><span class="token punctuation">{</span>                rel <span class="token operator">=</span> <span class="token function">mul</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">case</span> <span class="token number">4</span><span class="token punctuation">:</span><span class="token punctuation">{</span>                rel <span class="token operator">=</span> <span class="token function">div</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token keyword">default</span><span class="token punctuation">:</span><span class="token punctuation">{</span>                <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"错误的操作"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"结果:%d \n"</span><span class="token punctuation">,</span>rel<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"是否继续: [0.退出 1.继续]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%d"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>建立好以后,我们退回到Calc目录下面,执行ndk-build,这样就可以构建出我们想要的执行文件,对应的文件会在各个平台对应的文件夹内生成</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>ARM汇编学习(一)</title>
      <link href="/2020/02/28/arm-hui-bian-xue-xi-yi/"/>
      <url>/2020/02/28/arm-hui-bian-xue-xi-yi/</url>
      
        <content type="html"><![CDATA[<p>title: ARM汇编学习(一)<br>date: 2020-03-01 17:22:07<br>tags: </p><ul><li>ARM汇编</li><li>寄存器</li><li>指令</li></ul><h1 id="ARM汇编学习-一"><a href="#ARM汇编学习-一" class="headerlink" title="ARM汇编学习(一)"></a>ARM汇编学习(一)</h1><h2 id="ARM处理器基础之寻址方式"><a href="#ARM处理器基础之寻址方式" class="headerlink" title="ARM处理器基础之寻址方式"></a>ARM处理器基础之寻址方式</h2><h5 id="1-寄存器寻址"><a href="#1-寄存器寻址" class="headerlink" title="1.寄存器寻址"></a>1.寄存器寻址</h5><pre><code>寄存器寻址，简单来说就是把ARM寄存器内的值直接赋给另外一个ARM寄存器，是一种非常常见的寻址方式，有点类似于我们编程中，把变量A的值直接赋给B的操作。var B=A;例子如下MOV  R1,R2  ;把寄存器R2里面的值赋值个R1SUB  R0,R1,R2 ;使用寄存器R1减去R2 结果赋值给R0寄存器</code></pre><h5 id="2-立即寻址"><a href="#2-立即寻址" class="headerlink" title="2.立即寻址"></a>2.立即寻址</h5><pre><code>立即寻址就是直接把值赋给对应的变量（寄存器）,这和我们C语言里面给变量赋一个具体的数值很像var A = 10;例子如下SUBS R0,R0,#1 ;R0-1 -&gt; R0 寄存器R0-1的值保存到R0中</code></pre><h5 id="3-寄存器偏移寻址"><a href="#3-寄存器偏移寻址" class="headerlink" title="3.寄存器偏移寻址"></a>3.寄存器偏移寻址</h5><pre><code>寄存器偏移寻址是ARM指令集特有的寻址方式，当第二个操作数是寄存器偏移方式时,第二个寄存器操作数在与第一个操作数结合之前，选择进行位移操作这样的操作其实类似于我们在C语言里面，先把变量进行位移操作,然后再赋值给其他var A= B&gt;&gt;1;例子如下MOV R0,R2,LSL #3  ;R2的值左移3位，结果放入R0，即R0=R2*8ANDS R1,R1,R2,LSL R3  ;R2的值左移3位，然后和R1相与操作，结果放入R1</code></pre><pre><code>寄存器寻址可以使用的位移操作符如下LSL:逻辑左移，寄存器中低端空出的位置补0LSR:逻辑右移，寄存器中高端空出的位置补0ASR:算数右移，位移过程中，符号位保持不变，如果源操作数为正数，则高位空出补0，否则补1ROR:循环右移，由字的低端移出的位填入字的高端空位RRX:带扩展的循环右移，操作数右移一位，高端空出的位用原C标志值填充</code></pre><p><img src="https://zhanweisun.github.io/image/%E4%BD%8D%E7%A7%BB%E6%93%8D%E4%BD%9C%E5%9B%BE.png" alt="位移操作图"></p><h5 id="4-寄存器间接寻址"><a href="#4-寄存器间接寻址" class="headerlink" title="4,寄存器间接寻址"></a>4,寄存器间接寻址</h5><pre><code>这种寻址方式，就是取第二个参数寄存器编号里面的值，然后赋值给第一个寄存器类似于C语言中的var a=*b;例子程序LDR R1,[R2]  ;将R2中的数值作为地址，去除此地址中的数据保存在R1中SWP R1,R1,[R2] ;将R2中的数值作为地址，取出此地址中的数值与R1中的值交换</code></pre><h5 id="5-基址寻址"><a href="#5-基址寻址" class="headerlink" title="5.基址寻址"></a>5.基址寻址</h5><pre><code>将基址寄存器的内容与指令中给出的偏移量相加，获取到有效的地址，一般情况，基址寻址用于访问基址附近的存贮单元，经常用于查表，数组操作等。此操作类似于寄存器寻址，只是额外会再加上一个偏移地址例子程序LDR R2,[R3,#0x0F] ;将R3中的数值加0x0F作为地址，去除地址的数值保存到R2中</code></pre><h5 id="6-多寄存器寻址"><a href="#6-多寄存器寻址" class="headerlink" title="6.多寄存器寻址"></a>6.多寄存器寻址</h5><pre><code>多寄存器寻址就是一次可以传送几个几寄存器的值，允许一条指令传送16个寄存器的任何子集或者所有寄存器例子程序LDMIA R1!,{R2-R7,R12} ;将R1短语中的数据读出到R2-R7，R12，R1自动加1STMIA R0!,{R3-R6,R10} ;将R3-R6，R10中的数据保存到R0指向的地址，R0自动加1</code></pre><h5 id="7-堆栈寻址"><a href="#7-堆栈寻址" class="headerlink" title="7.堆栈寻址"></a>7.堆栈寻址</h5><pre><code>堆栈寻址使用专门的寄存器，堆栈指针指向一块存储区域，指针指向的存储单元就是堆栈顶端，存储器堆栈分为两种，向上生长：向高地址方向生长，称之为递增堆栈向下生长：向低地址方向生长，称之为递减堆栈堆栈指针指向最后压入的堆栈的有效数据项，成为满堆栈，堆栈指针指向下一个要放入的空位置，成为空堆栈，这样就有4种类型的堆栈表示递增和递减的满堆栈和空堆栈</code></pre><pre><code>满递增:堆栈通过增大存储器的地址向上增长，堆栈指针指向内含有效数据项的最高地址。例如指令 LDMFA，STMFA等.</code></pre><pre><code>空递增:堆栈通过增大存储器的地址向上增长，堆栈指针指向堆栈上的第一个空位置，例如指令 LDMEA,STMFA等.</code></pre><pre><code>满递减:堆栈通过减小存储器的地址向下增长，堆栈指针指向内含有效数据项的最低地址。例如指令 LDMFD，STMFD等.</code></pre><pre><code>空递减:堆栈通过减小存储器的地址向下增长，堆栈指针指向堆栈下的第一个空位置。例如指令 LDMFD，STMFD等.</code></pre><p>STMFD  SP!,{R1-R7,LR} ;将R1-R7，LR入栈，满递减堆栈</p><h5 id="8-块拷贝寻址"><a href="#8-块拷贝寻址" class="headerlink" title="8.块拷贝寻址"></a>8.块拷贝寻址</h5><pre><code>多寄存器传送指令用于一块数据从存储器的某一位置拷贝到另一位置。有点类似多寄存器寻址例子代码STMIA  R0!,{R1,R7} ;将R1-R7的数据保存到存储器，存储器地址保存在R0中，R0递增</code></pre><h5 id="9-相对寻址"><a href="#9-相对寻址" class="headerlink" title="9.相对寻址"></a>9.相对寻址</h5><pre><code>相对寻址是基址寻址的另外一个变种，有程序计数器PC提供基准地址，指令中的地址码字段作为偏移量，两者相加后得到有效地址例子代码BL ROUTE1  ;调用到ROUTE1子程序BEQ LOOP  ；条件跳转指令</code></pre><h2 id="ARM指令集"><a href="#ARM指令集" class="headerlink" title="ARM指令集"></a>ARM指令集</h2><h5 id="1-条件码"><a href="#1-条件码" class="headerlink" title="1.条件码"></a>1.条件码</h5><table><thead><tr><th>条件码助记符</th><th>影响标志位</th><th>含义</th></tr></thead><tbody><tr><td>EQ</td><td>Z==1</td><td>相等</td></tr><tr><td>NE</td><td>Z==0</td><td>不相等</td></tr><tr><td>CS/HS</td><td>C=1</td><td>无符号数大于或等于</td></tr><tr><td>CC/L0</td><td>C=0</td><td>无符号数小于</td></tr><tr><td>MI</td><td>N=1</td><td>负数</td></tr><tr><td>PL</td><td>N=0</td><td>正数或零</td></tr><tr><td>VS</td><td>V=1</td><td>溢出</td></tr><tr><td>VC</td><td>V=0</td><td>没有溢出</td></tr><tr><td>HI</td><td>C=1,Z=0</td><td>无符号数大于</td></tr><tr><td>LS</td><td>C=0,Z=1</td><td>无符号书小于或等于</td></tr><tr><td>GE</td><td>N=V</td><td>有符号数大于或等于</td></tr><tr><td>LT</td><td>N!=V</td><td>有符号数小于</td></tr><tr><td>GT</td><td>Z=0,N=V</td><td>有符号数大于</td></tr><tr><td>LE</td><td>Z=1,N!=V</td><td>有符号数小于或等于</td></tr><tr><td>AL</td><td>Any</td><td>无条件执行</td></tr></tbody></table><pre><code>条件码应用举例C语言代码if (a&gt;b){  a++;}else{  b++;}对应的ARM指令,其中R0为a,R1为bCMP      R0, R1        ;R0与R1比较ADDHI    R0, R0, #1    ;如果R0&gt;R1,R0=R0+1ADDLS    R1, R1, #1    ;否则R0&lt;R1,R1=R1+1if ((a!=10)&amp;&amp;(b!=20)){      a=a+b;}对应ARM指令,其中R0为a,R1为bCMP    R0,#10    ;比较R0是否为10CMPNE  R1,#20    ;如果R0不为10,则比较R1是否为20ADDNE  R0,R0,R1  ;如果R0不为10,并且R1不为20,指令执行R0=R0+R1</code></pre><h5 id="2-存储器访问指令"><a href="#2-存储器访问指令" class="headerlink" title="2.存储器访问指令"></a>2.存储器访问指令</h5><table><thead><tr><th>助记符</th><th>说明</th><th>操作</th><th>条件码位置</th></tr></thead><tbody><tr><td>LDR  Rd,addressing</td><td>加载字数据</td><td>Rd&lt;-[addressing],addressing 索引</td><td>LDR {cond}</td></tr><tr><td>LDRB  Rd,addressing</td><td>加载无符号字节数据</td><td>Rd&lt;-[addressing],addressing 索引</td><td>LDR {cond} B</td></tr><tr><td>LDRT  Rd,addressing</td><td>以用户模式加载字数据</td><td>Rd&lt;-[addressing],addressing 索引</td><td>LDR {cond} T</td></tr><tr><td>LDRBT  Rd,addressing</td><td>以用户模式加载无符号字数据</td><td>Rd&lt;-[addressing],addressing 索引</td><td>LDR {cond} BT</td></tr><tr><td>LDRH  Rd,addressing</td><td>加载无符号半字数据</td><td>Rd&lt;-[addressing],addressing 索引</td><td>LDR {cond} H</td></tr><tr><td>LDRSB  Rd,addressing</td><td>加载有符字节数据</td><td>Rd&lt;-[addressing],addressing 索引</td><td>LDR {cond} SB</td></tr><tr><td>LDRSH  Rd,addressing</td><td>STRH Rd,addressing</td><td>Rd&lt;-[addressing],addressing 索引</td><td>LDR {cond} SH</td></tr><tr><td>STR Rd,addressing</td><td>存储字数据</td><td>[addressing]&lt;-Rd,addressing 索引</td><td>STR {cond}</td></tr><tr><td>STRB  Rd,addressing</td><td>存储字节数据</td><td>[addressing]&lt;-Rd,addressing 索引</td><td>STR {cond} B</td></tr><tr><td>STRT Rd,addressing</td><td>以用户模式存储字数据</td><td>[addressing]&lt;-Rd,addressing 索引</td><td>STR {cond} T</td></tr><tr><td>STRBT Rd,addressing</td><td>以用户模式存储字节数据</td><td>[addressing]&lt;-Rd,addressing 索引</td><td>STR {cond} BT</td></tr><tr><td>STRH Rd,addressing</td><td>存储半字数据</td><td>[addressing]&lt;-Rd,addressing 索引</td><td>STR {cond} H</td></tr><tr><td>LDM {mode} Rn{!},reglist</td><td>批量(寄存器)加载</td><td>reglist &lt;- [Rn … ], Rn 回存等</td><td>LDM {cond} {more}</td></tr><tr><td>STM {mode} Rn{!},reglist</td><td>批量(寄存器)存储</td><td>[Rn … ] &lt;- reglist, Rn 回存等</td><td>STM {cond} {more}</td></tr><tr><td>SWP  Rd,Rm,Rn</td><td>寄存器和存储器字数据交换</td><td>Rd&lt;-[Rd],[Rn]&lt;-[Rm] (Rn &lt;&gt; Rd或Rm)</td><td>SWP {cond}</td></tr><tr><td>SWPB Rd,Rm,Rn</td><td>寄存器和存储器字节数据交换</td><td>Rd&lt;-[Rd],[Rn]&lt;-[Rm] (Rn &lt;&gt; Rd或Rm)</td><td>SWP {cond} B</td></tr></tbody></table><h6 id="LDR和STR"><a href="#LDR和STR" class="headerlink" title="LDR和STR"></a>LDR和STR</h6><pre><code>加载/存储无符号字节指令,使用单一数据传送指令STR和LDR来存储和加载数据指令格式如下LDR {cond} {T}  Rd,&lt;address&gt;;加载指定地址上的数据(字),放入Rd中STR {cond} {T}  Rd,&lt;address&gt;;存储数据(字)到指定地址的存储单元,要存储的数据在Rd中LDR {cond}B {T}  Rd,&lt;address&gt;;加载字节数据,放入Rd中,既Rd最低字节有效,高24位清零STR {cond}B {T}  Rd,&lt;address&gt;;存储字节数据,要存储的数据在Rd中,最低字节有效其中T为可选后缀,若指令中带有T,那么即使处理器是在特权模式下,存储系统也将访问看成是处理器在用户模式下</code></pre><pre><code>立即数立即数可以是个无符号数值,这个数据可以加到基址寄存器,也可以从基址寄存器中减去这个数值,指令举例如下:LDR R1,[R0,#0x12]; 将R0+0x12地址处的数据独处,保存到R1中,R0的值不变LDR R1,[R0] ;将R0地址处的数据读出,保存到R1中,0地址偏移</code></pre><pre><code>寄存器寄存器内的数值可以加到基址寄存器,也可以从基址寄存器中减去这个数值,指令举例如下:LDR R1,[R0,R2] ;将R0+R2地址的数据读出,保存到R1中(R0值不变)LDR R1,[R0,-R2];将R0-R2的地址处的数据读出,保存到R1中,(R0值不变)</code></pre><pre><code>寄存器及位移常数寄存器移位后的值可以加到基址寄存器,也可以从基址寄存器中减去这个数值,指令举例如下:LDR R1,[R0,R2,LSL #2]  ;将R0+R2*4(R2左移2位)的地址保存到R1中LDR R1,[R0,-R2,LSL #2] ;将R0-R2*4(R2左移2位)的地址保存到R1中寻址方式的地址计算方法分为加载/存储指令等4种形式1.零偏移Rn的值作为传送数据的地址,既偏移地址为0LDR Rd,[Rn]2.前索引偏移在数据传送前,将偏移量加到Rn中,其结果作为传送数据的存储地址,若使用后缀!,则结果回写到Rn中,且Rn的值不允许为R15,指令举例如下:LDR Rd,[Rn,#0x04]!LDR Rd,[Rn,#-0x04]3.程序相对偏移程序相对偏移是索引行驶的另外一个版本,汇编器由PC寄存器计算偏移量,并将PC寄存器作为Rn生成前索引指令,不能使用后缀&quot;!&quot;,指令举例如下:LDR Rd,label ;label 为程序标号,label必须是当前指令的正负4K范围内4.后索引偏移Rn的值用作传送数据的存储地址,在数据传送后,将偏移量与Rn想家结果回写到Rn中,Rn不允许是R15,指令举例如下:LDR Rd,[Rn],#0x04地址对准,大多数情况下,必须保证用于32位传送的地址是32位对准的.加载/存储字和无符号字节紫菱举例如下:LDR R2,[R5]        ;加载R5对应的地址上的数据到R2中STR R1,[R0,#0x04]  ;将R1中的数据保存到地址R0+0x04对应的存储单元中,R0不变LDRB R3,[R2],#1    ;读取R2地址上的1字节数据并保存到R3中,R3=R2+1STRB R6,[R7]       ;读取R6的数据保存到R7指定的地址中,值存储一个字节加载/存储半字和带符号字节,这类LDR/STR指令可能加载带符号数据,偏移量格式,寻址方式与上面相同,具体指令如下:LDR{cond}SB Rd,&lt;address&gt;  ;加载指定地址上的数据(带符号字节),放入Rd中LDR{cond}SH Rd,&lt;address&gt;  ;加载指定地址上的数据(带符号字节),放入Rd中LDR{cond}H Rd,&lt;address&gt;   ;加载半字数据,放入Rd中,既Rd最低的16位有效,高16位清零STR{cond}H Rd,&lt;address&gt;   ;存储半字数据,要存储的数据在Rd,最低16位有效说明:带符号位的半字,字加载是指带符号位加载扩展到32位;无符号位半字加载是指令扩展到32位.地址对准:对半字传输的地址必须为偶数,非半字对准的半字加载将使Rd内容不可靠,非半字对准的半字存储将使指定的2字节存储内容不可靠加载/存储半字和带符号字节指令举例如下:LDRSB R1 [R0,R3]   ;将R0+R3地址傻姑娘的字节数据读取到R1,高24位用符号位扩展LDRSH R1,[R9]      ;将R9地址上的半字数据读出到R1,高16位用符号位扩展LDRH  R6,[R2],#2   ;将R2地址的半字数据读出到R6,高16位用零扩展SHRH  R1,[R0,#2]!  ;将R1的数据存储到R0+2的地址中,只存储低位的2个字节数据R0=R0+2(R0的值增加2)LDR/STR指令用于对内存变量的访问,内存缓冲区数据访问,查表,外围部件的控制操作等.</code></pre><h6 id="LDM和STM"><a href="#LDM和STM" class="headerlink" title="LDM和STM"></a>LDM和STM</h6><pre><code>批量加载/存储指令可以实现一组寄存器和一块连续的内存单元之间的传输数据,LDM为加载多个寄存器,STM为存储多个寄存器,允许一条指令传送16个寄存器的任何子集或者所有寄存器,指令格式如下:LDM{cond}&lt;模式&gt; Rn{!},reglist{^}STM{cond}&lt;模式&gt; Rn{!},reglist{^}其中可使用的模式如下:1.IA:每次传送后地址加42.IB:每次传送前地址加43.DA:每次传送后地址减44.DB:每次传送前地址减45.FD:满递减堆栈6.ED:空递增堆栈7.FA:满递增堆栈8.EA:空递增堆栈其中Rn为基址寄存器,Rn不允许为R15,后缀!表示最后的地址歇会到Rn中,寄存器列表reglist可包含多于一个寄存器或者寄存器范围.使用,分开,如{R1,R2,R6-R9},寄存器排列由小到大排列.&quot;^&quot;后缀不允许在用户模式举例如下:LDMIA R0!,{R3-R9}    ;加载R0指向的地址上的多字数据,保存到R3-R9中,R0值更新STMIA R1!,{R3-R9}    ;将R3-R9的数据存储到R1只想的地址上,R1值更新STMfD SP!,{R0-R7,LR} ;保存现场,将R0-R7,LR入栈LDMFD SP!,{R0-R7,PC} ;恢复现场,异常处理返回</code></pre><p><img src="https://zhanweisun.github.io/image/STMDA.png" alt="STMDA"></p><p><img src="https://zhanweisun.github.io/image/STMDB.png" alt="STMDB"></p><p><img src="https://zhanweisun.github.io/image/STMIA.png" alt="STMIA"></p><p><img src="https://zhanweisun.github.io/image/STMIB.png" alt="STMIB"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Android面试之Handler相关学习</title>
      <link href="/2020/02/12/android-mian-shi-zhi-handler-xiang-guan-xue-xi/"/>
      <url>/2020/02/12/android-mian-shi-zhi-handler-xiang-guan-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>###Android面试之Handler相关学习</p><h5 id="1-Android消息机制之Looper-java源代码学习"><a href="#1-Android消息机制之Looper-java源代码学习" class="headerlink" title="1.Android消息机制之Looper.java源代码学习"></a>1.Android消息机制之Looper.java源代码学习</h5><p>1). 准备阶段,在子线程中调用Looper.prepare()方法或者在主线程调用Looper.prepareMainLooper()方法来创建当前的Looper对象</p><p>2).Looper对象内部会创建消息队列,代码如下</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//Looper.java源代码</span>    <span class="token comment" spellcheck="true">// sThreadLocal.get() will return null unless you've called prepare().</span>        <span class="token comment" spellcheck="true">//sThreadLocal是当前子线程与绑定的Looper</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> ThreadLocal<span class="token operator">&lt;</span>Looper<span class="token operator">></span> sThreadLocal <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>Looper<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Looper sMainLooper<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// guarded by Looper.class</span>    <span class="token keyword">final</span> MessageQueue mQueue<span class="token punctuation">;</span></code></pre><p>我们在调用Looper.prepare()的时候会调用如下代码</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Only one Looper may be created per thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        sThreadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Looper</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里会产生一个Looper实例,Looper里面包含有mQueue</span>    <span class="token punctuation">}</span></code></pre><p>主线程MainLooper产生的代码,由Android环境调用产生,不需要我们手工调用</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * Initialize the current thread as a looper, marking it as an     * application's main looper. The main looper for your application     * is created by the Android environment, so you should never need     * to call this function yourself.  See also: {@link #prepare()}     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepareMainLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Looper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>sMainLooper <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"The main Looper has already been prepared."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            sMainLooper <span class="token operator">=</span> <span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Returns the application's main looper, which lives in the main thread of the application.     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Looper <span class="token function">getMainLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Looper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> sMainLooper<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>Looper.loop()代码都做了什么,我们来仔细阅读一下,我会加入响应的一些注释.</p><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">/**     * Run the message queue in this thread. Be sure to call     * {@link #quit()} to end the loop.     * 返回当前线程的消息队列,确定在结束Loop的时候调用quit(),后面我们再来分析quit()做了什么     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Looper me <span class="token operator">=</span> <span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//获取当前线程的looper</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>me <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//looper为空就抛出异常</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"No Looper; Looper.prepare() wasn't called on this thread."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//获取到looper对应的消息队列</span>        <span class="token keyword">final</span> MessageQueue queue <span class="token operator">=</span> me<span class="token punctuation">.</span>mQueue<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// Make sure the identity of this thread is that of the local process,</span>        <span class="token comment" spellcheck="true">// and keep track of what that identity token actually is.</span>        Binder<span class="token punctuation">.</span><span class="token function">clearCallingIdentity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">long</span> ident <span class="token operator">=</span> Binder<span class="token punctuation">.</span><span class="token function">clearCallingIdentity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//为了方便查看,我删除了一些不相关代码</span>                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>                <span class="token comment" spellcheck="true">//重点循环,主要的内容在下面</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Message msg <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// might block ,取出消息体,有可能阻塞线程,当没有消息的时候会阻塞线程</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// No message indicates that the message queue is quitting.</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//为了方便查看,我删除了一些不相关代码</span>                    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token keyword">final</span> <span class="token keyword">long</span> dispatchStart <span class="token operator">=</span> needStartTime <span class="token operator">?</span> SystemClock<span class="token punctuation">.</span><span class="token function">uptimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">final</span> <span class="token keyword">long</span> dispatchEnd<span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                msg<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">dispatchMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//分配消息,其实这个才是最重要的. msg.target是一个handler,handler的分配消息被调用,而且因为这个是在一个for的死循环里面,所以这个就是不停的再获取队列消息并分配出去</span>                dispatchEnd <span class="token operator">=</span> needEndTime <span class="token operator">?</span> SystemClock<span class="token punctuation">.</span><span class="token function">uptimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>              <span class="token comment" spellcheck="true">//为了方便查看,我删除了一些不相关代码</span>                            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">//为了方便查看,我删除了一些不相关代码</span>                        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true">// Make sure that during the course of dispatching the</span>            <span class="token comment" spellcheck="true">// identity of the thread wasn't corrupted.</span>            <span class="token keyword">final</span> <span class="token keyword">long</span> newIdent <span class="token operator">=</span> Binder<span class="token punctuation">.</span><span class="token function">clearCallingIdentity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">//为了方便查看,我删除了一些不相关代码</span>                        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            msg<span class="token punctuation">.</span><span class="token function">recycleUnchecked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>3).使用线程对应的Handler发送消息</p><p>我们可以调用handler的sendMessage()发送到Message到MessageQueue并唤醒阻塞的MessageQueue</p><h5 id="2-一个线程能否创建多个Handler-Handler与Looper的对应关系"><a href="#2-一个线程能否创建多个Handler-Handler与Looper的对应关系" class="headerlink" title="2.一个线程能否创建多个Handler?Handler与Looper的对应关系?"></a>2.一个线程能否创建多个Handler?Handler与Looper的对应关系?</h5><p>我们可以从1中的代码发现,线程与Looper之间的关系,在prepare()方法内,代码的关联是针对线程和Looper的,Handler发送消息的时候是使用enqueueMessage方法,将消息传递到Looper的队列中的,消息到达队列以后,会在loop方法中执行获取消息 Message msg = queue.next();  方法,并使用 msg.target.dispatchMessage(msg); 分配消息出去,其中,target是handler.</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Only one Looper may be created per thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        sThreadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Looper</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这里会产生一个Looper实例,Looper里面包含有mQueue</span>    <span class="token punctuation">}</span></code></pre><p>总结:</p><p>一个线程可以创建多个Handler,但是只会有一个Looper并对应一个内含的MessageQueue.Handler与Looper之间没有直接对应关系</p><p>Handler通过sendMessage发送消息时，就会将handler对象存储到message中，然后Looper在loop中通过MessageQueue的next方法取出消息后，会通过之前消息封装的handler将消息发送到指定的handler，即通过调用msg.target.dispatchMessage方法</p><h5 id="3-Handler引起内存泄露的一些情况以及应对策略"><a href="#3-Handler引起内存泄露的一些情况以及应对策略" class="headerlink" title="3.Handler引起内存泄露的一些情况以及应对策略"></a>3.Handler引起内存泄露的一些情况以及应对策略</h5><p>1).在handler的handleMessage内进行了对activity的引用,同时又使用了handler发送延时消息的情况.会在当前引用的Activity销毁的时候引起内存泄露问题,具体情况如下</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 下面的情况会导致handler对Activity的一个引用*/</span><span class="token keyword">private</span> Handler handler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">handleMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>DemoActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token string">"内存泄露测试"</span><span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_LONG<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//当我们用Handler.sendMessageDelay等方法延迟发送消息的时候,Activity关闭了,这就会导致DemoActivity.this的引用无法被释放.</span></code></pre><p>正确做法如下</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">//正确情况,先要保证销毁Activity的时候,去除所有的callback和mesage</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onDestroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>handler<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>            handler<span class="token punctuation">.</span><span class="token function">removeCallbacksAndMessages</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//在handler内是使用引用的时候,也要注意使用弱引用而不是直接使用对应的Activity.这样保证在Activity销毁的时候可以正确被释放,如果是使用runnable,而且是非静态内部类,也会造成类似的内存泄露,所以解决方案类似.</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">MyHandler</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span><span class="token punctuation">{</span>        <span class="token keyword">private</span> WeakReference<span class="token operator">&lt;</span>MainActivity<span class="token operator">></span>reference<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">MyHandler</span><span class="token punctuation">(</span>MainActivity activity<span class="token punctuation">)</span><span class="token punctuation">{</span>            reference <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>activity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">handleMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>            MainActivity activity <span class="token operator">=</span> reference<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>activity<span class="token operator">!=</span>null<span class="token punctuation">)</span><span class="token punctuation">{</span>                Toast<span class="token punctuation">.</span><span class="token function">makeText</span><span class="token punctuation">(</span>activity<span class="token punctuation">,</span> <span class="token string">"测试"</span><span class="token punctuation">,</span> Toast<span class="token punctuation">.</span>LENGTH_SHORT<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">show</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                activity<span class="token punctuation">.</span>tv<span class="token punctuation">.</span><span class="token function">setText</span><span class="token punctuation">(</span><span class="token string">"测试"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> Handler </tag>
            
            <tag> 面试题 </tag>
            
            <tag> Looper </tag>
            
            <tag> MessageQueue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java泛型相关学习</title>
      <link href="/2020/02/12/java-fan-xing-xiang-guan-xue-xi/"/>
      <url>/2020/02/12/java-fan-xing-xiang-guan-xue-xi/</url>
      
        <content type="html"><![CDATA[<h3 id="Java泛型相关学习"><a href="#Java泛型相关学习" class="headerlink" title="Java泛型相关学习"></a>Java泛型相关学习</h3><h5 id="1-什么是泛型"><a href="#1-什么是泛型" class="headerlink" title="1.什么是泛型"></a>1.什么是泛型</h5><p>泛型，即”参数化类型”,在不创建新的类型的情况下,通过泛型指定不同类型来控制形参具体参数类型.这种参数类型可以用在类,接口,方法中,分别被称作泛型类,泛型接口,泛型方法.</p><p>泛型只在编译阶段有效,参数的类型是在编译阶段就确定了,编译器会在生成的代码中是用确定的类型替换.</p><h5 id="2-泛型类"><a href="#2-泛型类" class="headerlink" title="2.泛型类"></a>2.泛型类</h5><p>泛型类的最基本写法</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> 类名称 <span class="token operator">&lt;</span>泛型标识：可以随便写任意标识号，标识指定的泛型的类型<span class="token operator">></span><span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Generic</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">//key这个成员变量的类型为T,T的类型由外部指定  </span>    <span class="token keyword">private</span> T key<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Generic</span><span class="token punctuation">(</span>T key<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//泛型构造方法形参key的类型也为T，T的类型由外部指定</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> T <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment" spellcheck="true">//泛型方法getKey的返回值类型为T，T的类型由外部指定</span>        <span class="token keyword">return</span> key<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="3-泛型接口"><a href="#3-泛型接口" class="headerlink" title="3.泛型接口"></a>3.泛型接口</h5><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//定义一个泛型接口</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Generator</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> T <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>实现一个泛型接口</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 未传入泛型实参时，与泛型类的定义相同，在声明类的时候，需将泛型的声明也一起加到类中 * 即：class FruitGenerator&lt;T> implements Generator&lt;T>{ * 如果不声明泛型，如：class FruitGenerator implements Generator&lt;T>，编译器会报错："Unknown class" */</span><span class="token keyword">class</span> <span class="token class-name">FruitGenerator</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Generator</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> T <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="4-泛型通配符"><a href="#4-泛型通配符" class="headerlink" title="4.泛型通配符"></a>4.泛型通配符</h5><p>类型通配符一般是使用?代表具体的类型实参,实际使用的时候可以是对应的类型,可以代表所有类型的父类.</p><h5 id="5-泛型方法可变参数"><a href="#5-泛型方法可变参数" class="headerlink" title="5.泛型方法可变参数"></a>5.泛型方法可变参数</h5><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token keyword">void</span> <span class="token function">printMsg</span><span class="token punctuation">(</span> T<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">for</span><span class="token punctuation">(</span>T t <span class="token operator">:</span> args<span class="token punctuation">)</span><span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"泛型测试"</span><span class="token punctuation">,</span><span class="token string">"t is "</span> <span class="token operator">+</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h5 id="6-泛型边界限制"><a href="#6-泛型边界限制" class="headerlink" title="6.泛型边界限制"></a>6.泛型边界限制</h5><p>有时候我们要对泛型的类型进行限制,必须是某一些类型而不是全部类型,就需要用到泛型边界</p><p>例子</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">showKeyValue1</span><span class="token punctuation">(</span>Generic<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token operator">></span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>    Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"泛型测试"</span><span class="token punctuation">,</span><span class="token string">"key value is "</span> <span class="token operator">+</span> obj<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 泛型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Say hello to x86_64 Assembly [part 8]</title>
      <link href="/2020/01/11/say-hello-to-x86-64-assembly-part-8/"/>
      <url>/2020/01/11/say-hello-to-x86-64-assembly-part-8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/0xAX/asm" target="_blank" rel="noopener">翻译原文地址</a></p><h3 id="Say-hello-to-x86-64-Assembly-part-8"><a href="#Say-hello-to-x86-64-Assembly-part-8" class="headerlink" title="Say hello to x86_64 Assembly [part 8]"></a>Say hello to x86_64 Assembly [part 8]</h3><p>这是Say hello to x86_64 Assembly的第八部分，也是最后一部分，下面我们将介绍如何在汇编程序中使用非整数。使用浮点数据有两种方法：</p><ul><li>fpu</li><li>sse</li></ul><p>It is eight and final part of Say hello to x86_64 Assembly and here we will take a look on how to work with non-integer numbers in assembler. There are a couple of ways how to work with floating point data:</p><ul><li>fpu</li><li>sse</li></ul><p>首先让我们看看浮点数是如何存储在内存中的。有三种浮点数据类型：</p><ul><li>-单精度</li><li>-双精度</li><li>-双扩展精度</li></ul><p>First of all let’s look how floating point number stored in memory. There are three floating point data types:</p><ul><li>single-precision</li><li>double-precision</li><li>double-extended precision</li></ul><p>如英特尔64-ia-32-architecture-software-developer-vol-1-手册所述：</p><p>As Intel’s 64-ia-32-architecture-software-developer-vol-1-manual described:</p><pre><code>这些数据类型的数据格式直接对应于IEEE标准754中为二进制浮点运算指定的格式。</code></pre><pre><code>The data formats for these data types correspond directly to formats specified in the IEEE Standard 754 for Binary Floating-Point Arithmetic.</code></pre><p>内存中显示的单精度浮点数据：</p><ul><li>符号-1位</li><li>指数-8位</li><li>尾数-23位</li></ul><p>Single-precision floating-point float point data presented in memory:</p><ul><li>sign - 1 bit</li><li>exponent - 8 bits</li><li>mantissa - 23 bits</li></ul><p>例如，如果我们有以下数字：</p><p>So for example if we have following number:</p><pre><code>| sign  | exponent | mantissa|-------|----------|-------------------------| 0     | 00001111 | 110000000000000000000000</code></pre><p>指数可以是-128到127之间的8位有符号整数，也可以是0到255之间的8位无符号整数。符号位是零，所以我们有正数。指数为0000111b或15（十进制）。对于单精度位移是127，这意味着我们需要计算指数-127或15-127=-112。由于尾数的标准化二进制整数部分始终等于1，因此尾数中只记录其小数部分，因此尾数或我们的数字是1110000000000000000000000。结果值为：</p><p>Exponent is either an 8 bit signed integer from −128 to 127 or an 8 bit unsigned integer from 0 to 255. Sign bit is zero, so we have positive number. Exponent is 00001111b or 15 in decimal. For single-precision displacement is 127, it means that we need to calculate exponent - 127 or 15 - 127 = -112. Since the normalized binary integer part of the mantissa is always equal to one, then in the mantissa is recorded only its fractional part, so mantissa or our number is 1,110000000000000000000000. Result value will be:</p><pre><code>value = mantissa * 2^-112</code></pre><p>双精度数是64位内存，其中：</p><ul><li>符号-1位</li><li>指数-11位</li><li>尾数-52位</li></ul><p>Double precision number is 64 bit of memory where:</p><ul><li>sign - 1 bit</li><li>exponent - 11 bit</li><li>mantissa - 52 bit</li></ul><p>结果编号：</p><p>Result number we can get by:</p><pre><code>value = (-1)^sign * (1 + mantissa / 2 ^ 52) * 2 ^ exponent - 1023)</code></pre><p>扩展精度是80位数字，其中：</p><ul><li>符号-1位</li><li>指数-15位</li><li>尾数-112位</li></ul><p>Extended precision is 80 bit numbers where:</p><ul><li>sign - 1 bit</li><li>exponent - 15 bit</li><li>mantissa - 112 bit</li></ul><p>阅读更多信息-<a href="https://en.wikipedia.org/wiki/Extended_precision" target="_blank" rel="noopener">这里</a>。让我们看一个简单的例子。</p><p>Read more about it - <a href="https://en.wikipedia.org/wiki/Extended_precision" target="_blank" rel="noopener">here</a>. Let’s look at simple example.</p><h4 id="x87-FPU"><a href="#x87-FPU" class="headerlink" title="x87 FPU"></a>x87 FPU</h4><p>x87浮点单元（FPU）提供高性能浮点处理。它支持浮点、整数和压缩BCD整数数据类型以及浮点处理算法。x87提供以下指令集：</p><ul><li>-数据传输指令</li><li>-基本算术指令</li><li>-比较说明</li><li>-超越指令</li><li>-加载常数指令</li><li>-x87 FPU控制指令</li></ul><p>The x87 Floating-Point Unit (FPU) provides high-performance floating-point processing. It supports the floating-point, integer, and packed BCD integer data types and the floating-point processing algorithms. x87 provides following instructions set:</p><ul><li>Data transfer instructions</li><li>Basic arithmetic instructions</li><li>Comparison instructions</li><li>Transcendental instructions</li><li>Load constant instructions</li><li>x87 FPU control instructions</li></ul><p>当然，我们在这里不会看到x87提供的所有说明，有关更多信息，请参阅64-ia-32-architecture-software-developer-vol-1-manual第8章。有一些数据传输指令：</p><ul><li><code>FDL</code> - 加载浮点</li><li><code>FST</code> - 存储浮点（在ST（0）寄存器中）</li><li><code>FSTP</code> - 存储浮点和pop（在ST（0）寄存器中）</li></ul><p>Of course we will not see all instructions here provided by x87, for additional information see 64-ia-32-architecture-software-developer-vol-1-manual Chapter 8. There are a couple of data transfer instructions:</p><ul><li><code>FDL</code> - load floating point</li><li><code>FST</code> - store floating point (in ST(0) register)</li><li><code>FSTP</code> - store floating point and pop (in ST(0) register)</li></ul><p>算术指令：</p><ul><li><code>FADD</code>-添加浮点</li><li><code>FIADD</code>-将整数添加到浮点</li><li><code>FSUB</code>-减去浮点</li><li><code>FISUB</code>-从浮点减去整数</li><li><code>FABS</code>-获取绝对值</li><li><code>FIMUL</code>-整数与浮点相乘</li><li><code>FIDIV</code>-设备整数和浮点</li></ul><p>等等…FPU有8个10字节的寄存器组织在一个环形堆栈中。堆栈顶部-寄存器ST（0），其他寄存器是ST（1），ST（2）…ST（7）。我们通常在处理浮点数据时使用它。</p><p>Arithmetic instructions:</p><ul><li><code>FADD</code> - add floating point</li><li><code>FIADD</code> - add integer to floating point</li><li><code>FSUB</code> - subtract floating point</li><li><code>FISUB</code> - subtract integer from floating point</li><li><code>FABS</code> - get absolute value</li><li><code>FIMUL</code> - multiply integer and floating point</li><li><code>FIDIV</code> - device integer and floating point</li></ul><p>and etc… FPU has eight 10 byte registers organized in a ring stack. Top of the stack - register ST(0), other registers are ST(1), ST(2) … ST(7). We usually uses it when we are working with floating point data.</p><p>例子:</p><p>For example:</p><pre class=" language-assembly"><code class="language-assembly">section .data    x dw 1.0fld dword [x]</code></pre><p>将x的值推送到这个堆栈。运算符可以是32位、64位或80位。它和通常的堆栈一样工作，如果我们使用fld推送另一个值，x值将在ST（1）中，新值将在ST（0）中。FPU指令可以使用这些寄存器，例如：</p><p>pushes value of x to this stack. Operator can be 32bit, 64bit or 80bit. It works as usual stack, if we push another value with fld, x value will be in ST(1) and new value will be in ST(0). FPU instructions can use these registers, for example:</p><pre class=" language-assembly"><code class="language-assembly">;;;; adds st0 value to st3 and saves it in st0;;fadd st0, st3;;;; adds x and y and saves it in st0;;fld dword [x]fld dword [y]fadd</code></pre><p>让我们看一个简单的例子。我们将得到圆半径，计算圆平方并打印出来：</p><p>Let’s look on simple example. We will have circle radius and calculate circle square and print it:</p><pre class=" language-assembly"><code class="language-assembly">extern printResultsection .data        radius    dq  1.7        result    dq  0        SYS_EXIT  equ 60        EXIT_CODE equ 0global _startsection .text_start:        fld qword [radius]        fld qword [radius]        fmul        fldpi        fmul        fstp qword [result]        mov rax, 0        movq xmm0, [result]        call printResult        mov rax, SYS_EXIT        mov rdi, EXIT_CODE        syscall</code></pre><p>让我们试着理解它是如何工作的：首先，有一个带有预定义的radius数据和结果的数据部分，我们将使用它来存储结果。这2个常量用于调用退出系统调用。接下来我们看到程序的入口点-\u开始。在那里，我们用fld指令将radius值存储在st0和st1中，并用fmul指令将这两个值相乘。在这个操作之后，我们将在st0寄存器中得到半径乘法的结果。接下来，我们用fldpi指令将数字π加载到st0寄存器，然后radius<em>radius值将在st1寄存器中。在st0（pi）和st1（radius</em>radius的值）上执行fmul乘法后，结果将在st0寄存器中。好的，现在我们在st0寄存器中有了圆平方，可以用fstp指令将其提取出来。下一点是将结果传递给C函数并调用它。请记住，我们在上一篇博客文章中从程序集代码调用C函数。我们需要知道x86_64调用约定。通常我们通过寄存器rdi（arg1）、rsi（arg2）等传递函数参数，但这里是浮点数据。sse提供特殊寄存器：xmm0-xmm15。首先，我们需要将xmmN寄存器的个数放入rax寄存器（对于我们的情况是0），并将结果放入xmm0寄存器。现在我们可以调用C函数来打印结果：</p><p>Let’s try to understand how it works: First of all there is data section with predefined radius data and result which we will use for storing result. After this 2 constants for calling exit system call. Next we see entry point of program - _start. There we stores radius value in st0 and st1 with fld instruction and multiply this two values with fmul instruction. After this operations we will have result of radius on radius multiplication in st0 register. Next we load The number π with fldpi instruction to the st0 register, and after it radius * radius value will be in st1 register. After this execute multiplication with fmul on st0 (pi) and st1 (value of radius * radius), result will be in st0 register. Ok, now we have circle square in st0 register and can extract it with fstp instruction to the result. Next point is to pass result to the C function and call it. Remember we call C function from assembly code in previous blog post. We need to know x86_64 calling convention. In usual way we pass function parameters through registers rdi (arg1), rsi (arg2) and etc…, but here is floating point data. There is special registers: xmm0 - xmm15 provided by sse. First of all we need to put number of xmmN register to rax register (0 for our case), and put result to xmm0 register. Now we can call C function for printing result:</p><pre class=" language-C"><code class="language-C">#include <stdio.h>extern int printResult(double result);int printResult(double result) {    printf("Circle radius is - %f\n", result);    return 0;}</code></pre><p>我们可以用下面命令构建:</p><p>We can build it with:</p><pre><code>build:    gcc  -g -c circle_fpu_87c.c -o c.o    nasm -f elf64 circle_fpu_87.asm -o circle_fpu_87.o    ld   -dynamic-linker /lib64/ld-linux-x86-64.so.2 -lc circle_fpu_87.o  c.o -o testFloat1clean:    rm -rf *.o    rm -rf testFloat1</code></pre><p>运行:</p><p>And run:</p>]]></content>
      
      
      
        <tags>
            
            <tag> x86 </tag>
            
            <tag> x64 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Say hello to x86_64 Assembly [part 7]</title>
      <link href="/2020/01/11/say-hello-to-x86-64-assembly-part-7/"/>
      <url>/2020/01/11/say-hello-to-x86-64-assembly-part-7/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/0xAX/asm" target="_blank" rel="noopener">翻译原文地址</a></p><h3 id="Say-hello-to-x86-64-Assembly-part-7"><a href="#Say-hello-to-x86-64-Assembly-part-7" class="headerlink" title="Say hello to x86_64 Assembly [part 7]"></a>Say hello to x86_64 Assembly [part 7]</h3><p>这是Say hello to x86_64 Assembly的第七部分，在这里我们将学习如何将C与汇编程序一起使用。</p><p>It is seventh part of Say hello to x86_64 Assembly and here we will look on how we can use C together with assembler.</p><p>实际上，我们有三种方法可以一起使用：</p><ul><li>-从C代码调用程序集例程</li><li>-从程序集代码调用c例程</li><li>-在C代码中使用内联程序集</li></ul><p>Actually we have 3 ways to use it together:</p><ul><li>Call assembly routines from C code</li><li>Call c routines from assembly code</li><li>Use inline assembly in C code</li></ul><p>让我们编写3个简单的Hello world程序，演示如何将assembly和C结合使用。</p><p>Let’s write 3 simple Hello world programs which shows us how to use assembly and C together.</p><h4 id="从C调用汇编"><a href="#从C调用汇编" class="headerlink" title="从C调用汇编"></a>从C调用汇编</h4><p>Call assembly from C</p><p>首先让我们编写如下简单的C程序：</p><p>First of all let’s write simple C program like this:</p><pre class=" language-C"><code class="language-C">#include <string.h>int main() {    char* str = "Hello World\n";    int len = strlen(str);    printHelloWorld(str, len);    return 0;}</code></pre><p>在这里我们可以看到定义了两个变量的C代码：我们将要写入stdout的Hello world字符串和这个字符串的长度。接下来我们调用printHelloWorld汇编函数，并将这两个变量作为参数。当我们使用x86_64Linux时，我们必须知道x86_64Linux调用转换，所以我们将知道如何编写printHelloWorld函数，如何获取传入参数等…当我们调用函数时，前六个参数通过rdi、rsi、rdx、rcx、r8和r9通用寄存器，所有其他都通过堆栈。因此，我们可以从rdi和rsi寄存器中获取第一个和第二个参数，并调用写入 syscall并使用ret指令从函数返回：</p><p>Here we can see C code which defines two variables: our Hello world string which we will write to stdout and length of this string. Next we call printHelloWorld assembly function with this 2 variables as parameters. As we use x86_64 Linux, we must know x86_64 linux calling convetions, so we will know how to write printHelloWorld function, how to get incoming parameters and etc… When we call function first six parameters passes through rdi, rsi, rdx, rcx, r8 and r9 general purpose registers, all another through the stack. So we can get first and second parameter from rdi and rsi registers and call write syscall and than return from function with ret instruction:</p><pre class=" language-assembly"><code class="language-assembly">global printHelloWorldsection .textprintHelloWorld:        ;; 1 arg        mov r10, rdi        ;; 2 arg        mov r11, rsi        ;; call write syscall        mov rax, 1        mov rdi, 1        mov rsi, r10        mov rdx, r11        syscall        ret</code></pre><p>现在我们可以构建它;</p><p>Now we can build it with:</p><pre><code>build:    nasm -f elf64 -o casm.o casm.asm    gcc casm.o casm.c -o casm</code></pre><h4 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h4><p>Inline assembly</p><p>下面的方法是直接在C代中码编写汇编代码。这里有特殊的语法。它的总体观点是：</p><p>The following method is to write assembly code directly in C code. There is special syntax for this. It has general view:</p><pre><code>asm [volatile] (&quot;assembly code&quot; : output operand : input operand : clobbers);</code></pre><p>正如我们在gcc文档中看到的，volatile关键字意味着：</p><p>As we can read in gcc documentation volatile keyword means:</p><pre><code>扩展asm语句的典型用途是操作输入值以生成输出值。但是，你的asm语句也可能产生副作用。如果是，您可能需要使用volatile限定符来禁用某些优化</code></pre><pre><code>The typical use of Extended asm statements is to manipulate input values to produce output values. However, your asm statements may also produce side effects. If so, you may need to use the volatile qualifier to disable certain optimizations</code></pre><p>每个操作数由约束字符串和括号中的C表达式描述。有许多限制：</p><p>Each operand is described by constraint string followed by C expression in parentheses. There are a number of constraints:</p><ul><li><p>r—通用寄存器中的保留变量值</p></li><li><p>g—允许使用任何寄存器、内存或立即整数操作数，但不是通用寄存器的寄存器除外。</p></li><li><p>f—浮点寄存器</p></li><li><p>m—允许使用内存操作数，通常使用计算机支持的任何类型的地址。</p></li><li><p>等等…</p></li><li><p><code>r</code> - Kept variable value in general purpose register</p></li><li><p><code>g</code> - Any register, memory or immediate integer operand is allowed, except for registers that are not general registers.</p></li><li><p><code>f</code> - Floating point register</p></li><li><p><code>m</code> - A memory operand is allowed, with any kind of address that the machine supports in general.</p></li><li><p>and etc…</p></li></ul><p>所以我们的hello world是：</p><p>So our hello world will be:</p><pre class=" language-C"><code class="language-C">#include <string.h>int main() {    char* str = "Hello World\n";    long len = strlen(str);    int ret = 0;    __asm__("movq $1, %%rax \n\t"        "movq $1, %%rdi \n\t"        "movq %1, %%rsi \n\t"        "movl %2, %%edx \n\t"        "syscall"        : "=g"(ret)        : "g"(str), "g" (len));    return 0;}</code></pre><p>这里我们可以看到与前面的示例和内联汇编定义中相同的2个变量。首先，我们将1放入rax和rdi寄存器（编写系统调用号和stdout），就像在我们的普通汇编hello world中那样。接下来，我们对rsi和rdi寄存器执行类似的操作，但第一个操作数以%symbol开始，而不是$。这意味着str是由%1引用的输出操作数，len是由%2引用的第二个输出操作数，因此我们用%n表示法将str和len的值放入rsi和rdi，其中n是输出操作数的个数。此外，寄存器名前面还有一个%%。</p><p>Here we can see the same 2 variables as in previous example and inline assembly definition. First of all we put 1 to rax and rdi registers (write system call number, and stdout) as we did it in our plain assembly hello world. Next we do similar operation with rsi and rdi registers but first operands starts with % symbol instead $. It means str is the output operand referred by %1 and len second output operand referred by %2, so we put values of str and len to rsi and rdi with %n notation, where n is number of output operand. Also there is %% prefixed to the register name.</p><pre><code>这有助于GCC区分操作数和寄存器。操作数有一个%作为前缀</code></pre><pre><code>    This helps GCC to distinguish between the operands and registers. operands have a single % as prefix</code></pre><p>我们可以用以下方法构建它：</p><p>We can build it with:</p><pre><code>build:    gcc casm.c -o casm</code></pre><h4 id="从汇编调用C"><a href="#从汇编调用C" class="headerlink" title="从汇编调用C"></a>从汇编调用C</h4><p>Call C from assembly</p><p>最后一个方法是从汇编代码中调用C函数。例如，我们有以下简单的C代码，其中一个函数只打印Hello world：</p><p>And the last method is to call C function from assembly code. For example we have following simple C code with one function which just prints Hello world:</p><pre class=" language-C"><code class="language-C">#include <stdio.h>extern int print();int print() {    printf("Hello World\n");    return 0;}</code></pre><p>现在，我们可以在汇编代码中将此函数定义为extern，并使用call指令调用它，就像我们在前面的文章中多次这样：</p><p>Now we can define this function as extern in our assembly code and call it with call instruction as we do it much times in previous posts:</p><pre class=" language-asssembly"><code class="language-asssembly">global _startextern printsection .text_start:        call print        mov rax, 60        mov rdi, 0        syscall</code></pre><p>构建它：</p><p>Build it with:</p><pre><code>build:    gcc  -c casm.c -o c.o    nasm -f elf64 casm.asm -o casm.o    ld   -dynamic-linker /lib64/ld-linux-x86-64.so.2 -lc casm.o c.o -o casm</code></pre><p>现在我们可以运行第三个hello world了。</p><p>and now we can run our third hello world.</p>]]></content>
      
      
      
        <tags>
            
            <tag> x86 </tag>
            
            <tag> x64 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Say hello to x86_64 Assembly [part 6]</title>
      <link href="/2020/01/11/say-hello-to-x86-64-assembly-part-6/"/>
      <url>/2020/01/11/say-hello-to-x86-64-assembly-part-6/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/0xAX/asm" target="_blank" rel="noopener">翻译原文地址</a></p><h3 id="Say-hello-to-x86-64-Assembly-part-6"><a href="#Say-hello-to-x86-64-Assembly-part-6" class="headerlink" title="Say hello to x86_64 Assembly [part 6]"></a>Say hello to x86_64 Assembly [part 6]</h3><p>这是Say hello to x86_64 Assembly的第六部分，在这里我们将研究AT&amp;T汇编程序语法。以前我们在所有部分都使用nasm assembler，但是还有其他一些具有不同语法的汇编程序fasm、yasm和其他。正如我在上面写的，我们将研究gas（GNU汇编程序）及其语法和nasm之间的区别。GCC使用GNU汇编程序，因此如果您在汇编程序输出中看到简单的hello world：</p><p>It is sixth part of Say hello to x86_64 Assembly and here we will look on AT&amp;T assembler syntax. Previously we used nasm assembler in all parts, but there are some another assemblers with different syntax, fasm, yasm and others. As i wrote above we will look on gas (GNU assembler) and difference between it’s syntax and nasm. GCC uses GNU assembler, so if you see at assembler output for simple hello world:</p><pre class=" language-C"><code class="language-C">#include <unistd.h>int main(void) {    write(1, "Hello World\n", 15);    return 0;}</code></pre><p>您将看到以下输出：</p><p>You will see following output:</p><pre class=" language-assembly"><code class="language-assembly">    .file    "test.c"    .section    .rodata.LC0:    .string    "Hello World\n"    .text    .globl    main    .type    main, @functionmain:.LFB0:    .cfi_startproc    pushq    %rbp    .cfi_def_cfa_offset 16    .cfi_offset 6, -16    movq    %rsp, %rbp    .cfi_def_cfa_register 6    movl    $15, %edx    movl    $.LC0, %esi    movl    $1, %edi    call    write    movl    $0, %eax    popq    %rbp    .cfi_def_cfa 7, 8    ret    .cfi_endproc.LFE0:    .size    main, .-main    .ident    "GCC: (Ubuntu 4.9.1-16ubuntu6) 4.9.1"    .section    .note.GNU-stack,"",@progbits</code></pre><p>看起来与nasm不一样的Hello world，让我们看看有些什么不同。</p><p>Looks different then nasm Hello world, let’s look on some differences.</p><h4 id="AT-amp-T-语法"><a href="#AT-amp-T-语法" class="headerlink" title="AT&amp;T 语法"></a>AT&amp;T 语法</h4><p>AT&amp;T syntax</p><h4 id="节"><a href="#节" class="headerlink" title="节"></a>节</h4><p>Sections</p><p>我不知道你怎么样，但当我开始编写汇编程序时，通常是从节定义开始的。让我们看一个简单的例子：</p><p>I don’t know how about you, but when I start to write assembler program, usually I’m starting from sections definition. Let’s look on simple example:</p><pre class=" language-assembly"><code class="language-assembly">.data    //    // 初始化数据定义 initialized data definition    //.text    .global _start_start:    //    // 主程序 main routine    //</code></pre><p>你可以在这里注意到两个小小的区别：<br>-节定义以开头以.符号<br>-主程序定义使用.globl,而不是像我们在nasm中那样使用global<br>gas还使用另一个指令来定义数据：</p><p>You can note two little differences here:</p><ul><li>Section definition starts with . symbol</li><li>Main routine defines with .globl instead global as we do it in nasm</li></ul><p>Also gas uses another directives for data defintion:</p><pre class=" language-assembly"><code class="language-assembly">.section .data    // 1 byte    var1: .byte 10    // 2 byte    var2: .word 10    // 4 byte    var3: .int 10    // 8 byte    var4: .quad 10    // 16 byte    var5: .octa 10    // assembles each string (with no automatic trailing zero byte) into consecutive addresses    str1: .asci "Hello world"    // just like .ascii, but each string is followed by a zero byte    str2: .asciz "Hello world"    // Copy the characters in str to the object file    str3: .string "Hello world"</code></pre><p>操作数顺序使用nasm编写汇编程序时，数据操作的一般语法如下：</p><p>Operands order When we write assembler program with nasm, we have following general syntax for data manipulation:</p><pre class=" language-assembly"><code class="language-assembly">mov destination, source</code></pre><p>GNU 汇编有着相反的操作方向,即:</p><p>With GNU assembler we have back order i.e.:</p><pre class=" language-assembly"><code class="language-assembly">mov source, destination</code></pre><p>举例:</p><p>For example:</p><pre class=" language-assembly"><code class="language-assembly">;;;; nasm syntax;;mov rax, rcx//// gas syntax//mov %rcx, %rax</code></pre><p>另外，不能在这里使用%symbol注册开始元素。如果使用的是直接操作数，则需要使用<code>$</code>符号：</p><p>Also you can not here that registers starts with % symbol. If you’re using direct operands, need to use <code>$</code> symbol:</p><pre class=" language-assembly"><code class="language-assembly">movb $10, %rax</code></pre><h4 id="操作数大小和操作语法"><a href="#操作数大小和操作语法" class="headerlink" title="操作数大小和操作语法"></a>操作数大小和操作语法</h4><p>Size of operands and operation syntax</p><p>有时当我们需要获得部分内存时，例如64寄存器的第一个字节，我们使用以下语法：</p><p>Sometimes when we need to get part of memory, for example first byte of 64 register, we used following syntax:</p><pre class=" language-assembly"><code class="language-assembly">mov ax, word [rsi]</code></pre><p>在gas中进行此类操作还有另一种方法。我们不在操作数中定义大小，而是在指令中定义大小：</p><p>There is another way for such operations in gas. We don’t define size in operands but in instruction:</p><pre class=" language-assembly"><code class="language-assembly">movw (%rsi), %ax</code></pre><p>GNU汇编程序有6个操作后缀：</p><ul><li>b - 1 byte 操作符</li><li>w - 2 bytes 操作符</li><li>l - 4 bytes 操作符</li><li>q - 8 bytes 操作符</li><li>t - 10 bytes 操作符</li><li>o - 16 bytes 操作符</li></ul><p>GNU assembler has 6 postfixes for operations:</p><ul><li><code>b</code> - 1 byte operands</li><li><code>w</code> - 2 bytes operands</li><li><code>l</code> - 4 bytes operands</li><li><code>q</code> - 8 bytes operands</li><li><code>t</code> - 10 bytes operands</li><li><code>o</code> - 16 bytes operands</li></ul><p>这个规则不仅是mov指令，而且还适用于所有其他指令，如addl、xorb、cmpw等…</p><p>This rule is not only mov instruction, but also for all another like addl, xorb, cmpw and etc…</p><h4 id="内存访问"><a href="#内存访问" class="headerlink" title="内存访问"></a>内存访问</h4><p>Memory access</p><p>您可以注意到，我们在前面的示例中使用了（）括号，而在nasm示例中使用了[]。要解引用括号中的值，请使用GAS:（%rax），例如：</p><p>You can note that we used () brackets in previous example instead [] in nasm example. To dereference values in parentheses are used GAS: (%rax), for example:</p><pre class=" language-assembly"><code class="language-assembly">movq -8(%rbp),%rdimovq 8(%rbp),%rdi</code></pre><h4 id="跳转"><a href="#跳转" class="headerlink" title="跳转"></a>跳转</h4><p>Jumps</p><p>GNU汇编程序支持以下运算符用于远跳转函数调用和跳转：</p><p>GNU assembler supports following operators for far functions call and jumps:</p><pre class=" language-assembly"><code class="language-assembly">lcall $section, $offset</code></pre><p>远跳转-跳转到位于不同于当前代码段但处于相同权限级别的段中的指令，有时称为段间跳转。</p><p>Far jump - a jump to an instruction located in a different segment than the current code segment but at the same privilege level, sometimes referred to as an intersegment jump.</p><h4 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h4><p>Comments</p><p>GNU汇编程序支持3种类型的注释：</p><p>GNU assembler supports 3 types of comments:</p><pre><code>    # - 单行注释 single line comments    // - single line comments    /* */ - 多行注释 for multiline comments</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> x86 </tag>
            
            <tag> x64 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Say hello to x86_64 Assembly [part 5]</title>
      <link href="/2020/01/11/say-hello-to-x86-64-assembly-part-5/"/>
      <url>/2020/01/11/say-hello-to-x86-64-assembly-part-5/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/0xAX/asm" target="_blank" rel="noopener">翻译原文地址</a></p><h3 id="Say-hello-to-x86-64-Assembly-part-5"><a href="#Say-hello-to-x86-64-Assembly-part-5" class="headerlink" title="Say hello to x86_64 Assembly [part 5]"></a>Say hello to x86_64 Assembly [part 5]</h3><p>这是Say hello to x86_64 Assembly的第五部分，下面我们将介绍宏。它不会是关于x86_64的博客文章，主要是关于nasm汇编程序及其预处理器的。如果你对它感兴趣，请看下一篇。</p><p>It is a fifth part of Say hello to x86_64 Assembly and here we will look at macros. It will not be blog post about x86_64, mainly it will be about nasm assembler and it’s preprocessor. If you’re interesting in it read next.</p><h4 id="宏"><a href="#宏" class="headerlink" title="宏"></a>宏</h4><p>Macros</p><p>NASM支持两种形式的宏：<br>-单行<br>-多行<br>所有单行宏都必须从%define指令开始。其形式如下：</p><p>NASM supports two form of macro:</p><ul><li>single-line</li><li>multiline</li></ul><p>All single-line macro must start from %define directive. It form is following:</p><pre class=" language-assembly"><code class="language-assembly">%define macro_name(parameter) value</code></pre><p>Nasm宏的行为和外观与C中的非常相似。例如，我们可以创建以下单行宏：</p><p>Nasm macro behaves and looks very similar as in C. For example, we can create following single-line macro:</p><pre class=" language-assembly"><code class="language-assembly">%define argc rsp + 8%define cliArg1 rsp + 24</code></pre><p>在代码中使用它：</p><p>and than use it in code:</p><pre class=" language-assembly"><code class="language-assembly">;;;; argc will be expanded to rsp + 8;;mov rax, [argc]cmp rax, 3jne .mustBe3args</code></pre><p>多行宏以%macro nasm指令开头，以%endmacro结尾。一般形式如下：</p><p>Multiline macro starts with %macro nasm directive and end with %endmacro. It general form is following:</p><pre class=" language-assembly"><code class="language-assembly">%macro number_of_parameters    instruction    instruction    instruction%endmacro</code></pre><p>例如：</p><p>For example:</p><pre class=" language-assembly"><code class="language-assembly">%macro bootstrap 1          push ebp          mov ebp,esp%endmacro</code></pre><p>我们可以使用它：</p><p>And we can use it:</p><pre class=" language-assembly"><code class="language-assembly">_start:    bootstrap</code></pre><p>例如，让我们看看PRINT宏：</p><p>For example let’s look at PRINT macro:</p><pre class=" language-assembly"><code class="language-assembly">%macro PRINT 1    pusha    pushf    jmp %%astr%%str db %1, 0%%strln equ $-%%str%%astr: _syscall_write %%str, %%strlnpopfpopa%endmacro%macro _syscall_write 2    mov rax, 1        mov rdi, 1        mov rsi, %%str        mov rdx, %%strln        syscall%endmacro</code></pre><p>让我们试着浏览一下它的宏并了解它是如何工作的：在第一行，我们用一个参数定义了PRINT宏。然后推送所有通用寄存器（使用pusha指令）和标记寄存器（使用pushf指令）。在此之后，我们将跳转到%%astr label。请注意，宏中定义的所有标签必须以“%”开头。现在我们转到带2个参数的 __syscall_write宏。让我们看看系统调用写入实现。您可以记住，我们在以前的所有文章中都使用写入系统调用将字符串打印到stdout。看起来是这样的：</p><p>Let’s try to go through it macro and understand how it works: At first line we defined PRINT macro with one parameter. Than we push all general registers (with pusha instruction) and flag register with (with pushf instruction). After this we jump to %%astr label. Pay attention that all labels which defined in macro must start with %%. Now we move to __syscall_write macro with 2 parameter. Let’s look on __syscall_write implementation. You can remember that we use write system call in all previous posts for printing string to stdout. It looks like this:</p><pre class=" language-assembly"><code class="language-assembly">;; write syscall numbermov rax, 1;; file descriptor, standard outputmov rdi, 1;; message addressmov rsi, msg;; length of messagemov rdx, 14;; call write syscallsyscall</code></pre><p>在__syscall_write宏中，我们定义了前两条指令，用于将1放入rax（写系统调用号）和rdi（stdout文件描述符）。然后我们将%str放入rsi寄存器（指向字符串的指针），其中，%str是本地标签，它是PRINT宏的第一个参数（注意宏参数通过$parameter_number访问），以0结尾（每个字符串必须以0结尾）。以及计算字符串长度的%strlen。在此之后，我们使用syscall指令调用系统调用，仅此而已。</p><p>In our __syscall_write macro we define first two instruction for putting 1 to rax (write system call number) and rdi (stdout file descriptor). Than we put %%str to rsi register (pointer to string), where %%str is local label to which is get first parameter of PRINT macro (pay attention that macro parameter access by $parameter_number) and end with 0 (every string must end with zero). And %%strlen which calculates string length. After this we call system call with syscall instruction and that’s all.</p><p>Now we can use it:</p><pre class=" language-assembly"><code class="language-assembly">label: PRINT "Hello World!"</code></pre><h4 id="有用的标准宏"><a href="#有用的标准宏" class="headerlink" title="有用的标准宏"></a>有用的标准宏</h4><p>Useful standard macros</p><p>NASM支持以下标准宏：</p><p>NASM supports following standard macros:</p><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p>struc</p><p>我们可以使用’STRUC’和’ENDSTRUC’来定义数据结构。例如：</p><p>We can use <code>STRUC</code> and <code>ENDSTRUC</code> for data structure defintion. For example:</p><pre class=" language-assembly"><code class="language-assembly">struc person   name: resb 10   age:  resb 1endstruc</code></pre><p>现在我们可以举例说明我们的结构：</p><p>And now we can make instance of our structure:</p><pre class=" language-assembly"><code class="language-assembly">section .data    p: istruc person      at name db "name"      at age  db 25    iendsection .text_start:    mov rax, [p + person.name]</code></pre><h4 id="include"><a href="#include" class="headerlink" title="%include"></a>%include</h4><p>我们可以包含其他程序集文件并跳转到其中的标签或使用%include指令调用函数。</p><p>We can include other assembly files and jump to there labels or call functions with %include directive.</p>]]></content>
      
      
      
        <tags>
            
            <tag> x86 </tag>
            
            <tag> x64 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Say hello to x86_64 Assembly [part 4]</title>
      <link href="/2020/01/11/say-hello-to-x86-64-assembly-part-4/"/>
      <url>/2020/01/11/say-hello-to-x86-64-assembly-part-4/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/0xAX/asm" target="_blank" rel="noopener">翻译原文地址</a></p><h3 id="Say-hello-to-x86-64-Assembly-part-4"><a href="#Say-hello-to-x86-64-Assembly-part-4" class="headerlink" title="Say hello to x86_64 Assembly [part 4]"></a>Say hello to x86_64 Assembly [part 4]</h3><p>不久前，我开始写一系列关于x86_64汇编编程的博客文章。你可以通过asm标签找到它。不幸的是，我上次很忙，没有新的帖子，所以今天我继续写关于大会的帖子，并将努力做到每周。</p><p>Some time ago i started to write series of blog posts about assembly programming for x86_64. You can find it by asm tag. Unfortunately i was busy last time and there were not new post, so today I continue to write posts about assembly, and will try to do it every week.</p><p>今天我们要看字符串和一些字符串操作。我们仍然使用NASM汇编和Linux X86_64。</p><p>Today we will look at strings and some strings operations. We still use nasm assembler, and linux x86_64.</p><h4 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h4><p>Reverse string</p><p>当然，当我们谈论汇编语言时，我们不能谈论字符串数据类型，实际上我们是在处理字节数组。让我们尝试编写一个简单的示例，我们将定义字符串数据，并尝试将结果反向并通过stdout输出。当我们开始学习新的编程语言时，这些任务看起来非常简单和流行。让我们看看实现。<br>首先，我定义初始化数据。它将放在数据部分（您可以阅读有关部分的内容）：</p><p>Of course when we talk about assembly programming language we can’t talk about string data type, actually we’re dealing with array of bytes. Let’s try to write simple example, we will define string data and try to reverse and write result to stdout. This tasks seems pretty simple and popular when we start to learn new programming language. Let’s look on implementation.</p><p>First of all, I define initialized data. It will be placed in data section (You can read about sections in part):</p><pre class=" language-nasm"><code class="language-nasm"><span class="token keyword">section .data</span>        SYS_WRITE equ <span class="token number">1</span>        STD_OUT   equ <span class="token number">1</span>        SYS_EXIT  equ <span class="token number">60</span>        EXIT_CODE equ <span class="token number">0</span>        NEW_LINE db <span class="token number">0xa</span>        INPUT db <span class="token string">"Hello world!"</span></code></pre><p>这里我们可以看到四个常数：</p><ul><li>SYS_WRITE-“写入”系统调用号</li><li>STD_OUT-stdout文件描述符</li><li>SYS_EXIT-“退出”系统的Syscall号</li><li>EXIT_CODE-退出代码</li></ul><p>你可以在这里找到系统调用列表。也有定义：</p><ul><li>NEW_LINE-新行（\n）符号</li><li>INPUT-我们的输入字符串，我们将反转它</li></ul><p>接下来，我们为缓冲区定义bss部分，在这里我们将放置反向字符串：</p><p>Here we can see four constants:</p><ul><li><code>SYS_WRITE</code> - ‘write’ syscall number</li><li><code>STD_OUT</code> - stdout file descriptor</li><li><code>SYS_EXIT</code> - ‘exit’ syscall number</li><li><code>EXIT_CODE</code> - exit code</li></ul><p>syscall list you can find - here. Also there defined:</p><ul><li><code>NEW_LINE</code> - new line (\n) symbol</li><li><code>INPUT</code> - our input string, which we will reverse</li></ul><p>Next we define bss section for our buffer, where we will put reversed string:</p><pre class=" language-nasm"><code class="language-nasm"><span class="token keyword">section .bss</span>        OUTPUT resb <span class="token number">12</span></code></pre><p>好的，我们有一些数据和缓冲区用来存放结果，现在我们可以定义代码的文本段。让我们从主启动程序开始：</p><p>Ok we have some data and buffer where to put result, now we can define text section for code. Let’s start from main _start routine:</p><pre class=" language-nasm"><code class="language-nasm"><span class="token label function">_start:</span>        mov <span class="token register variable">rsi</span>, INPUT        xor <span class="token register variable">rcx</span>, <span class="token register variable">rcx</span>        cld        mov <span class="token register variable">rdi</span>, <span class="token operator">$</span> <span class="token operator">+</span> <span class="token number">15</span>        call calculateStrLength        xor <span class="token register variable">rax</span>, <span class="token register variable">rax</span>        xor <span class="token register variable">rdi</span>, <span class="token register variable">rdi</span>        jmp reverseStr</code></pre><p>这里有一些新东西。让我们看看它是如何工作的：首先，我们把INPUT的地址放在第2行的rsi寄存器中，就像我们写stdout和写零到rcx寄存器一样，它将是计算字符串长度的计数器。在第四行我们可以看到cld操作符。它将df flag重置为零。因为当我们计算字符串的长度时需要它，我们将遍历该字符串的内容元素，如果df flag为0，我们将从左到右处理字符串的符号。接下来我们调用calculateStrLength函数。我略过了有mov rdi指令的第5行，$+15指令，我稍后会告诉您。现在让我们看一下calculateStrength的实现：</p><p>Here are some new things. Let’s see how it works: First of all we put INPUT address to si register at line 2, as we did for writing to stdout and write zeros to rcx register, it will be counter for calculating length of our string. At line 4 we can see cld operator. It resets df flag to zero. We need in it because when we will calculate length of string, we will go through symbols of this string, and if df flag will be 0, we will handle symbols of string from left to right. Next we call calculateStrLength function. I missed line 5 with mov rdi, $ + 15 instruction, i will tell about it little later. And now let’s look at calculateStrLength implementation:</p><pre class=" language-nasm"><code class="language-nasm"><span class="token label function">calculateStrLength:</span>        <span class="token comment" spellcheck="true">;; check is it end of string</span>        cmp byte <span class="token operator">[</span><span class="token register variable">rsi</span><span class="token operator">]</span>, <span class="token number">0</span>        <span class="token comment" spellcheck="true">;; if yes exit from function</span>        je exitFromRoutine        <span class="token comment" spellcheck="true">;; load byte from rsi to al and inc rsi</span>        lodsb        <span class="token comment" spellcheck="true">;; push symbol to stack</span>        push <span class="token register variable">rax</span>        <span class="token comment" spellcheck="true">;; increase counter</span>        inc <span class="token register variable">rcx</span>        <span class="token comment" spellcheck="true">;; loop again</span>        jmp calculateStrLength</code></pre><p>正如您可以通过它的名称理解他的含义，它只计算输入字符串的长度并将结果存储在rcx寄存器中。首先，我们检查RSI寄存器不指向零，如果是，这是字符串的结尾，我们可以从函数中退出。接下来是lodsb指令。很简单， 他只是把1字节放到al寄存器（16位ax的低位）并更改rsi指针。当我们执行cld指令时，lodsb每次都将rsi从左到右移动到一个字节，因此我们将按字符串元素移动。之后，我们将rax值推送到堆栈，现在它包含字符串中的符号（lodsb将字节从si放到al，al是rax的低8位）。为什么我们要把符号推到堆栈上？你必须记住堆栈是如何工作的，它是按照后进先出的原则工作的。这对我们很有好处。我们将从si中获取第一个元素，将其推到堆栈中，而不是第二个元素，依此类推。所以在堆栈顶部会有字符串的最后一个元素。而不仅仅是从堆栈中逐元素弹出并写入输出缓冲区。在它之后，我们增加计数器（rcx）并再次循环到例程的开始。</p><p>As you can understand by it’s name, it just calculates length of INPUT string and store result in rcx register. First of all we check that rsi register doesn’t point to zero, if so this is the end of string and we can exit from function. Next is lodsb instruction. It’s simple, it just put 1 byte to al register (low part of 16 bit ax) and changes rsi pointer. As we executed cld instruction, lodsb everytime will move rsi to one byte from left to right, so we will move by string symbols. After it we push rax value to stack, now it contains symbol from our string (lodsb puts byte from si to al, al is low 8 bit of rax). Why we did push symbol to stack? You must remember how stack works, it works by principle LIFO (last input, first output). It is very good for us. We will take first symbol from si, push it to stack, than second and so on. So there will be last symbol of string at the stack top. Than we just pop symbol by symbol from stack and write to OUTPUT buffer. After it we increment our counter (rcx) and loop again to the start of routine.</p><p>好的，我们把所有的符号从字符串推到栈，现在我们可以跳转到exitFromRoutine返回到_start 这里。怎么做？我们有ret指令。代码是这样的：</p><p>Ok, we pushed all symbols from string to stack, now we can jump to exitFromRoutine return to _start there. How to do it? We have ret instruction for this. But if code will be like this:</p><pre class=" language-nasm"><code class="language-nasm"><span class="token label function">exitFromRoutine:</span>        <span class="token comment" spellcheck="true">;; return to _start</span>        ret</code></pre><p>它不会起作用的。为什么？这很棘手。记得我们在开始时调用calculateStrLength。当我们调用一个函数时会发生什么？首先，函数的参数从右向左推到堆栈。返回地址将推送到堆栈。所以函数将知道在执行结束后返回哪里。但是看看calculateStrength，我们将符号从字符串推送到堆栈，现在堆栈顶部没有返回地址，函数不知道返回到哪里。如何面对它。现在，我们必须在调用之前查看奇怪的指令：</p><p>It will not work. Why? It is tricky. Remember we called calculateStrLength at _start. What occurs when we call a function? First of all function’s parameters pushes to stack from right to left. After it return address pushes to stack. So function will know where to return after end of execution. But look at calculateStrLength, we pushed symbols from our string to stack and now there is no return address of stack top and function doesn’t know where to return. How to be with it. Now we must take a look to the weird instruction before call:</p><pre class=" language-nasm"><code class="language-nasm">mov <span class="token register variable">rdi</span>, <span class="token operator">$</span> <span class="token operator">+</span> <span class="token number">15</span></code></pre><p>首先：</p><ul><li>$-返回字符串内存中定义$的位置</li><li>$$-返回当前节开始的内存位置</li></ul><p>所以我们有mov rdi的位置，$+15，但是为什么我们在这里加15？听着，我们需要知道下一行在计算长度后的位置。让我们使用objdump util打开文件：</p><p>First all:</p><ul><li><code>$</code> - returns position in memory of string where $ defined</li><li><code>$$</code> - returns position in memory of current section start</li></ul><p>So we have position of mov rdi, $ + 15, but why we add 15 here? Look, we need to know position of next line after calculateStrLength. Let’s open our file with objdump util:</p><pre class=" language-nasm"><code class="language-nasm">objdump <span class="token operator">-</span>D reverse<span class="token label function">reverse:</span>     file format elf64<span class="token operator">-</span>x86<span class="token number">-64</span>Disassembly of section .text:00000000004000b0 <span class="token operator">&lt;</span>_start<span class="token operator">></span>:  4000b0:    <span class="token number">48</span> be <span class="token number">41</span> <span class="token number">01</span> <span class="token number">60</span> <span class="token number">00</span> <span class="token number">00</span>     movabs <span class="token operator">$</span><span class="token number">0x600141</span>,<span class="token operator">%</span><span class="token register variable">rsi</span>  4000b7:    <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span>  4000ba:    <span class="token number">48</span> <span class="token number">31</span> c9                 xor    <span class="token operator">%</span><span class="token register variable">rcx</span>,<span class="token operator">%</span><span class="token register variable">rcx</span>  4000bd:    fc                       cld  4000be:    <span class="token number">48</span> bf cd <span class="token number">00</span> <span class="token number">40</span> <span class="token number">00</span> <span class="token number">00</span>     movabs <span class="token operator">$</span><span class="token number">0x4000cd</span>,<span class="token operator">%</span><span class="token register variable">rdi</span>  4000c5:    <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span>  4000c8:    e8 <span class="token number">08</span> <span class="token number">00</span> <span class="token number">00</span> <span class="token number">00</span>           callq  4000d5 <span class="token operator">&lt;</span>calculateStrLength<span class="token operator">></span>  4000cd:    <span class="token number">48</span> <span class="token number">31</span> c0                 xor    <span class="token operator">%</span><span class="token register variable">rax</span>,<span class="token operator">%</span><span class="token register variable">rax</span>  4000d0:    <span class="token number">48</span> <span class="token number">31</span> ff                 xor    <span class="token operator">%</span><span class="token register variable">rdi</span>,<span class="token operator">%</span><span class="token register variable">rdi</span>  4000d3:    eb 0e                    jmp    <span class="token number">4000e3</span> <span class="token operator">&lt;</span>reverseStr<span class="token operator">></span></code></pre><p>我们可以看到，第12行（mov rdi，$+15）占用10个字节，第16-5行的函数调用占用15个字节。所以我们的回信地址是mov rdi，$+15。现在，我们可以将返回地址从rdi推送到堆栈并从函数返回：</p><p>We can see here that line 12 (our mov rdi, $ + 15) takes 10 bytes and function call at line 16 - 5 bytes, so it takes 15 bytes. That’s why our return address will be mov rdi, $ + 15. Now we can push return address from rdi to stack and return from function:</p><pre class=" language-nasm"><code class="language-nasm"><span class="token label function">exitFromRoutine:</span>        <span class="token comment" spellcheck="true">;; push return addres to stack again</span>        push <span class="token register variable">rdi</span>        <span class="token comment" spellcheck="true">;; return to _start</span>        ret</code></pre><p>现在我们回到起点。在调用calculateStrength之后，我们向rax和rdi写入零并跳转到reverseStr标签。具体实施如下：</p><p>Now we return to start. After call of the <code>calculateStrLength</code> we write zeros to rax and rdi and jump to reverseStr label. It’s implementation is following:</p><pre class=" language-nasm"><code class="language-nasm"><span class="token label function">reverseStr:</span>        cmp <span class="token register variable">rcx</span>, <span class="token number">0</span>        je printResult        pop <span class="token register variable">rax</span>        mov <span class="token operator">[</span>OUTPUT <span class="token operator">+</span> <span class="token register variable">rdi</span><span class="token operator">]</span>, <span class="token register variable">rax</span>        dec <span class="token register variable">rcx</span>        inc <span class="token register variable">rdi</span>        jmp reverseStr</code></pre><p>在这里，我们检查计数器，它是字符串的长度，如果它是零，我们将所有元素写入缓冲区，并可以打印它。检查完计数器后，我们从堆栈弹出到rax寄存器的第一个元素，并将其写入输出缓冲区。我们添加rdi是因为用另一种方法我们将符号写入缓冲区的第一个字节。在此之后，我们通过输出缓冲区增加移动下一个的rdi，减少长度计数器并跳到标签的开始。<br>执行reverseStr之后，我们在输出缓冲区中反转了字符串，可以用新行将结果写入stdout：</p><p>Here we check our counter which is length of string and if it is zero we wrote all symbols to buffer and can print it. After checking counter we pop from stack to rax register first symbol and write it to OUTPUT buffer. We add rdi because in other way we’ll write symbol to first byte of buffer. After this we increase rdi for moving next by OUTPUT buffer, decrease length counter and jump to the start of label.</p><p>After execution of reverseStr we have reversed string in OUTPUT buffer and can write result to stdout with new line:</p><pre class=" language-assembly"><code class="language-assembly">printResult:        mov rdx, rdi        mov rax, 1        mov rdi, 1        mov rsi, OUTPUT                syscall        jmp printNewLineprintNewLine:        mov rax, SYS_WRITE        mov rdi, STD_OUT        mov rsi, NEW_LINE        mov rdx, 1        syscall        jmp exit</code></pre><p>从我们的程序退出:</p><p>and exit from the our program:</p><pre class=" language-assembly"><code class="language-assembly">exit:        mov rax, SYS_EXIT        mov rdi, EXIT_CODE        syscall</code></pre><p>就这些,现在我们可以编译我们的程序:</p><p>That’s all, now we can compile our program with:</p><pre class=" language-makefile"><code class="language-makefile"><span class="token symbol">all</span><span class="token punctuation">:</span>    nasm -g -f elf64 -o reverse.o reverse.asm    ld -o reverse reverse.o<span class="token symbol">clean</span><span class="token punctuation">:</span>    rm reverse reverse.o</code></pre><p>并运行它:</p><p>and run it:</p><p>![](<a href="https://zhanweisun.github.io/image/Screenshot">https://zhanweisun.github.io/image/Screenshot</a> from 2014-11-20 19_51_15.png?raw=true)</p><h4 id="字符串操作"><a href="#字符串操作" class="headerlink" title="字符串操作"></a>字符串操作</h4><p>当然，还有许多其他的字符串/字节操作说明：</p><ul><li>REP-在rcx不为零时重复</li><li>MOVSB-复制字节字符串（MOVSW、MOVSD等）</li><li>CMPSB-字节字符串比较</li><li>SCASB-字节字符串扫描</li><li>STOSB-将字节写入字符串</li></ul><p>Of course there are many other instructions for string/bytes manipulations:</p><ul><li><code>REP</code> - repeat while rcx is not zero</li><li><code>MOVSB</code> - copy a string of bytes (MOVSW, MOVSD and etc..)</li><li><code>CMPSB</code> - byte string comparison</li><li><code>SCASB</code> - byte string scanning</li><li><code>STOSB</code> - write byte to string</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> x86 </tag>
            
            <tag> x64 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Say hello to x86_64 Assembly [part 3]</title>
      <link href="/2020/01/10/say-hello-to-x86-64-assembly-part-3/"/>
      <url>/2020/01/10/say-hello-to-x86-64-assembly-part-3/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/0xAX/asm" target="_blank" rel="noopener">翻译原文地址</a><a href="https://github.com/0xAX/asm" target="_blank" rel="noopener">翻译原文地址</a></p><h3 id="Say-hello-to-x86-64-Assembly-part-3"><a href="#Say-hello-to-x86-64-Assembly-part-3" class="headerlink" title="Say hello to x86_64 Assembly [part 3]"></a>Say hello to x86_64 Assembly [part 3]</h3><p>堆栈是存储器中的一个特殊区域，其工作原理是后进先出。</p><p>The stack is special region in memory, which operates on the principle lifo (Last Input, First Output).</p><p>我们有16个通用寄存器用于临时数据存储。它们是RAX、RBX、RCX、RDX、RDI、RSI、RBP、RSP和R8-R15。对于应用程序来说太少了。所以我们可以在堆栈中存储数据。堆栈的另一个用法是：当我们调用函数时，返回地址的副本保存在堆栈中。函数执行结束后，返回地址被复制到（RIP）中应用程序将继续从函数后的下一个位置执行。</p><p>We have 16 general-purpose registers for temporary data storage. They are RAX, RBX, RCX, RDX, RDI, RSI, RBP, RSP and R8-R15. It’s too few for serious applications. So we can store data in the stack. Yet another usage of stack is following: When we call a function, return address copied in stack. After end of function execution, address copied in commands counter (RIP) and application continue to executes from next place after function.</p><p>例子 :</p><pre class=" language-nasm"><code class="language-nasm"><span class="token keyword">global _start</span><span class="token keyword">section .text</span><span class="token label function">_start:</span>        mov <span class="token register variable">rax</span>, <span class="token number">1</span>        call incRax        cmp <span class="token register variable">rax</span>, <span class="token number">2</span>        jne exit        <span class="token comment" spellcheck="true">;;</span>        <span class="token comment" spellcheck="true">;; Do something</span>        <span class="token comment" spellcheck="true">;;</span><span class="token label function">incRax:</span>        inc <span class="token register variable">rax</span>        ret</code></pre><p>这里我们可以看到，在应用程序运行之后，rax等于1。然后我们调用incRax函数，它将rax值增加到1，现在rax值必须是2。在这个执行之后，继续从8行开始，我们将rax值与2进行比较。同样，我们可以在<a href="https://0xax.github.io/asm_3/www.x86-64.org/documentation/abi.pdf" target="_blank" rel="noopener">System V AMD64 ABI</a>中读取，前六个函数参数在寄存器中传递。他们是：</p><p>Here we can see that after application runnning, rax is equal to 1. Then we call a function incRax, which increases rax value to 1, and now rax value must be 2. After this execution continues from 8 line, where we compare rax value with 2. Also as we can read in <a href="https://0xax.github.io/asm_3/www.x86-64.org/documentation/abi.pdf" target="_blank" rel="noopener">System V AMD64 ABI</a>, the first six function arguments passed in registers. They are:</p><ul><li><p>rdi-第一个参数</p></li><li><p>rsi-第二个参数</p></li><li><p>rdx-第三个参数</p></li><li><p>rcx-第四个参数</p></li><li><p>r8-第五个参数</p></li><li><p>r9-第六个参数</p></li><li><p><code>rdi</code> - first argument</p></li><li><p><code>rsi</code> - second argument</p></li><li><p><code>rdx</code> - third argument</p></li><li><p><code>rcx</code> - fourth argument</p></li><li><p><code>r8</code> - fifth argument</p></li><li><p><code>r9</code> - sixth</p></li></ul><p>下一个参数将在堆栈中传递。如果我们有这样的函数：</p><p>Next arguments will be passed in stack. So if we have function like this:</p><pre class=" language-c"><code class="language-c"><span class="token keyword">int</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token keyword">int</span> a1<span class="token punctuation">,</span> <span class="token keyword">int</span> a2<span class="token punctuation">,</span> <span class="token keyword">int</span> a3<span class="token punctuation">,</span> <span class="token keyword">int</span> a4<span class="token punctuation">,</span> <span class="token keyword">int</span> a5<span class="token punctuation">,</span> <span class="token keyword">int</span> a6<span class="token punctuation">,</span> <span class="token keyword">int</span> a7<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>a1 <span class="token operator">+</span> a2 <span class="token operator">-</span> a3 <span class="token operator">-</span> a4 <span class="token operator">+</span> a5 <span class="token operator">-</span> a6<span class="token punctuation">)</span> <span class="token operator">*</span> a7<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>然后，前六个参数将在寄存器中传递，但7个参数将在堆栈中传递。</p><p>Then first six arguments will be passed in registers, but 7 argument will be passed in stack.</p><h4 id="堆栈指针"><a href="#堆栈指针" class="headerlink" title="堆栈指针"></a>堆栈指针</h4><p>Stack pointer</p><p>正如我所说，我们有16个通用寄存器，有两个有趣的寄存器-RSP和RBP。RBP是基指针寄存器。它指向当前堆栈帧的基部。RSP是堆栈指针，它指向当前堆栈帧的顶部。</p><p>As i wroute about we have 16 general-purpose registers, and there are two interesting registers - RSP and RBP. RBP is the base pointer register. It points to the base of the current stack frame. RSP is the stack pointer, which points to the top of current stack frame.</p><p>命令</p><p>Commands</p><p>我们有两个使用stack的命令：</p><ul><li><p>push 参数-递增堆栈指针（RSP）并将参数存储在堆栈指针所指向的位置</p></li><li><p>pop 参数-将数据从堆栈指针指向的位置复制到参数</p></li></ul><p>We have two commands for work with stack:</p><ul><li><code>push argument</code> - increments stack pointer (RSP) and stores argument in location pointed by stack pointer</li><li><code>pop argument</code> - copied data to argument from location pointed by stack pointer</li></ul><p>让我们看一个简单的例子:</p><p>Let’s look on one simple example:</p><pre class=" language-nasm"><code class="language-nasm"><span class="token keyword">global _start</span><span class="token keyword">section .text</span><span class="token label function">_start:</span>        mov <span class="token register variable">rax</span>, <span class="token number">1</span>        mov <span class="token register variable">rdx</span>, <span class="token number">2</span>        push <span class="token register variable">rax</span>        push <span class="token register variable">rdx</span>        mov <span class="token register variable">rax</span>, <span class="token operator">[</span><span class="token register variable">rsp</span> <span class="token operator">+</span> <span class="token number">8</span><span class="token operator">]</span>        <span class="token comment" spellcheck="true">;;</span>        <span class="token comment" spellcheck="true">;; Do something</span>        <span class="token comment" spellcheck="true">;;</span></code></pre><p>这里我们可以看到，我们把1放到rax寄存器，2放到rdx寄存器。之后，我们推送这些寄存器的值到堆栈中。堆栈起后进先出的作用。因此，在这个堆栈之后，我们的应用程序将具有以下结构：</p><p>Here we can see that we put 1 to rax register and 2 to rdx register. After it we push to stack values of these registers. Stack works as LIFO (Last In First Out). So after this stack or our application will have following structure:</p><p><img src="https://zhanweisun.github.io/image/Diagram.png?raw=true" alt="Diagram"></p><p>然后我们从地址为rsp+8的堆栈中复制值。这意味着我们得到栈顶的地址，再加上8，然后按这个地址将数据复制到rax。之后rax值为1。</p><p>Then we copy value from stack which has address rsp + 8. It means we get address of top of stack, add 8 to it and copy data by this address to rax. After it rax value will be 1.</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>Example</p><p>让我们看一个例子。我们将编写简单的程序，它将得到两个命令行参数。将获取此参数的和并打印结果。</p><p>Let’s see one example. We will write simple program, which will get two command line arguments. Will get sum of this arguments and print result.</p><pre class=" language-nasm"><code class="language-nasm"><span class="token keyword">section .data</span>        SYS_WRITE equ <span class="token number">1</span>        STD_IN    equ <span class="token number">1</span>        SYS_EXIT  equ <span class="token number">60</span>        EXIT_CODE equ <span class="token number">0</span>        NEW_LINE   db <span class="token number">0xa</span>        WRONG_ARGC db <span class="token string">"Must be two command line argument"</span>, <span class="token number">0xa</span></code></pre><p>首先，我们用一些值定义.data节。这里有四个用于Linux syscalls的常量，sys_write、sys_exit等等…我们还有两个字符串：第一个是新的行符号，第二个是错误消息。<br>让我们看看.text部分，它由程序代码组成：</p><p>First of all we define <code>.data</code> section with some values. Here we have four constants for linux syscalls, for sys_write, sys_exit and etc… And also we have two strings: First is just new line symbol and second is error message.</p><p>Let’s look on the <code>.text</code> section, which consists from code of program:</p><pre class=" language-nasm"><code class="language-nasm"><span class="token keyword">section .text</span>        <span class="token keyword">global _start</span><span class="token label function">_start:</span>        pop <span class="token register variable">rcx</span>        cmp <span class="token register variable">rcx</span>, <span class="token number">3</span>        jne argcError        add <span class="token register variable">rsp</span>, <span class="token number">8</span>        pop <span class="token register variable">rsi</span>        call str_to_int        mov <span class="token register variable">r10</span>, <span class="token register variable">rax</span>        pop <span class="token register variable">rsi</span>        call str_to_int        mov <span class="token register variable">r11</span>, <span class="token register variable">rax</span>        add <span class="token register variable">r10</span>, <span class="token register variable">r11</span></code></pre><p>让我们试着理解，这里发生了什么：在 _start label 指令之后，从堆栈中获取第一个值并将其放入rcx寄存器。如果使用命令行参数运行应用程序，则在按以下顺序运行之后，所有这些参数都将位于堆栈中：</p><p>Let’s try to understand, what is happening here: After _start label first instruction get first value from stack and puts it to rcx register. If we run application with command line arguments, all of their will be in stack after running in following order:</p><pre class=" language-nasm"><code class="language-nasm">    <span class="token operator">[</span><span class="token register variable">rsp</span><span class="token operator">]</span> <span class="token operator">-</span> top of stack will contain arguments count.    <span class="token operator">[</span><span class="token register variable">rsp</span> <span class="token operator">+</span> <span class="token number">8</span><span class="token operator">]</span> <span class="token operator">-</span> will contain argv<span class="token operator">[</span><span class="token number">0</span><span class="token operator">]</span>    <span class="token operator">[</span><span class="token register variable">rsp</span> <span class="token operator">+</span> <span class="token number">16</span><span class="token operator">]</span> <span class="token operator">-</span> will contain argv<span class="token operator">[</span><span class="token number">1</span><span class="token operator">]</span>    and so on...</code></pre><p>所以我们得到命令行参数count并把它放到rcx中。之后我们将rcx与3进行比较。如果它们不相等，我们跳到argcError标签，它只打印错误消息：</p><p>So we get command line arguments count and put it to rcx. After it we compare rcx with 3. And if they are not equal we jump to argcError label which just prints error message:</p><pre class=" language-nasm"><code class="language-nasm"><span class="token label function">argcError:</span>    <span class="token comment" spellcheck="true">;; sys_write syscall</span>    mov     <span class="token register variable">rax</span>, <span class="token number">1</span>    <span class="token comment" spellcheck="true">;; file descritor, standard output</span>    mov     <span class="token register variable">rdi</span>, <span class="token number">1</span>    <span class="token comment" spellcheck="true">;; message address</span>    mov     <span class="token register variable">rsi</span>, WRONG_ARGC    <span class="token comment" spellcheck="true">;; length of message</span>    mov     <span class="token register variable">rdx</span>, <span class="token number">34</span>    <span class="token comment" spellcheck="true">;; call write syscall</span>    syscall    <span class="token comment" spellcheck="true">;; exit from program</span>    jmp exit</code></pre><p>当我们有两个参数时为什么我们要和3比较。很简单。第一个参数是程序名，后面都是我们传递给程序的命令行参数。好的，如果我们传递了两个命令行参数，我们将转到10行。这里我们将rsp移到8，从而丢失了第一个参数——程序名。现在rsp指向我们传递的第一个命令行参数。我们用pop命令得到它，并将其放入rsi寄存器，然后调用函数将其转换为整数。接下来我们将阅读 str_to_int 实现。函数结束后，我们在rax寄存器中有整数值，并将其保存在r10寄存器中。在这之后我们做同样的操作但是用r11。最后，我们在r10和r11寄存器中有两个整数值，现在可以用add命令求出它的和。现在我们必须将结果转换为字符串并打印出来。让我们看看怎么做：</p><p>Why we compare with 3 when we have two arguments. It’s simple. First argument is a program name, and all after it are command line arguments which we passed to program. Ok, if we passed two command line arguments we go next to 10 line. Here we shift rsp to 8 and thereby missing the first argument - the name of the program. Now rsp points to first command line argument which we passed. We get it with pop command and put it to rsi register and call function for converting it to integer. Next we read about <code>str_to_int</code> implementation. After our function ends to work we have integer value in rax register and we save it in r10 register. After this we do the same operation but with r11. In the end we have two integer values in r10 and r11 registers, now we can get sum of it with add command. Now we must convert result to string and print it. Let’s see how to do it:</p><pre class=" language-nasm"><code class="language-nasm">mov <span class="token register variable">rax</span>, <span class="token register variable">r10</span><span class="token comment" spellcheck="true">;; number counter</span>xor <span class="token register variable">r12</span>, <span class="token register variable">r12</span><span class="token comment" spellcheck="true">;; convert to string</span>jmp int_to_str</code></pre><p>在这里，我们将命令行参数的和放入rax寄存器，将r12设置为零，并跳转到int_to_str。我们已经知道如何打印字符串，我们有什么可以打印。让我们看看str_to_int和int_to_str的实现。</p><p>Here we put sum of command line arguments to rax register, set r12 to zero and jump to int_to_str. Ok now we have base of our program. We already know how to print string and we have what to print. Let’s see at str_to_int and int_to_str implementation.</p><pre class=" language-nasm"><code class="language-nasm"><span class="token label function">str_to_int:</span>            xor <span class="token register variable">rax</span>, <span class="token register variable">rax</span>            mov <span class="token register variable">rcx</span>,  <span class="token number">10</span><span class="token label function">next:</span>        cmp <span class="token operator">[</span><span class="token register variable">rsi</span><span class="token operator">]</span>, byte <span class="token number">0</span>        je return_str        mov <span class="token register variable">bl</span>, <span class="token operator">[</span><span class="token register variable">rsi</span><span class="token operator">]</span>            sub <span class="token register variable">bl</span>, <span class="token number">48</span>        mul <span class="token register variable">rcx</span>        add <span class="token register variable">rax</span>, <span class="token register variable">rbx</span>        inc <span class="token register variable">rsi</span>        jmp next<span class="token label function">return_str:</span>        ret</code></pre><p>在str_to_int开始时，我们将rax设置为0，rcx设置为10。然后我们转到下一个标签。正如您在上面的示例中所看到的（str_to_int调用之前的第一行），我们从堆栈中将argv[1]放在rsi中。现在我们将rsi的第一个字节与0进行比较，因为每个字符串都以NULL结尾，如果是，我们将返回。如果不是0，我们将它的值复制到一个字节的bl寄存器，并从中减去48。为什么是48？从0到9的所有数字在asci表中都有48到57个代码。所以如果我们从数字符号48（例如从57）中减去，我们得到数字。然后在rcx上乘以rax（值为-10）。在此之后，我们增加rsi以获得下一个字节并再次循环。算法很简单。例如，如果rsi指向‘5’ ‘7’ ‘6’ ‘\000’序列，则将执行以下步骤：</p><p>At the start of str_to_int, we set up rax to 0 and rcx to 10. Then we go to next label. As you can see in above example (first line before first call of str_to_int) we put argv[1] in rsi from stack. Now we compare first byte of rsi with 0, because every string ends with NULL symbol and if it is we return. If it is not 0 we copy it’s value to one byte bl register and substract 48 from it. Why 48? All numbers from 0 to 9 have 48 to 57 codes in asci table. So if we substract from number symbol 48 (for example from 57) we get number. Then we multiply rax on rcx (which has value - 10). After this we increment rsi for getting next byte and loop again. Algorthm is simple. For example if rsi points to ‘5’ ‘7’ ‘6’ ‘\000’ sequence, then will be following steps:</p><pre class=" language-nasm"><code class="language-nasm">    <span class="token register variable">rax</span> <span class="token operator">=</span> <span class="token number">0</span>    get first byte <span class="token operator">-</span> <span class="token number">5</span> and put it to <span class="token register variable">rbx</span>    <span class="token register variable">rax</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token register variable">rax</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">*</span> <span class="token number">10</span>    <span class="token register variable">rax</span> <span class="token operator">=</span> <span class="token register variable">rax</span> <span class="token operator">+</span> <span class="token register variable">rbx</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">+</span> <span class="token number">5</span>    Get second byte <span class="token operator">-</span> <span class="token number">7</span> and put it to <span class="token register variable">rbx</span>    <span class="token register variable">rax</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">-</span><span class="token operator">-</span><span class="token operator">></span> <span class="token register variable">rax</span> <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">=</span> <span class="token number">50</span>    <span class="token register variable">rax</span> <span class="token operator">=</span> <span class="token register variable">rax</span> <span class="token operator">+</span> <span class="token register variable">rbx</span> <span class="token operator">=</span> <span class="token number">50</span> <span class="token operator">+</span> <span class="token number">7</span> <span class="token operator">=</span> <span class="token number">57</span>    and loop it while <span class="token register variable">rsi</span> is not \<span class="token number">000</span></code></pre><p>在str_to_int之后我们将得到rax中的数字。现在让我们看看int_to_str：</p><p>After str_to_int we will have number in rax. Now let’s look at int_to_str:</p><pre class=" language-nasm"><code class="language-nasm"><span class="token label function">int_to_str:</span>        mov <span class="token register variable">rdx</span>, <span class="token number">0</span>        mov <span class="token register variable">rbx</span>, <span class="token number">10</span>        div <span class="token register variable">rbx</span>        add <span class="token register variable">rdx</span>, <span class="token number">48</span>        add <span class="token register variable">rdx</span>, <span class="token number">0x0</span>        push <span class="token register variable">rdx</span>        inc <span class="token register variable">r12</span>        cmp <span class="token register variable">rax</span>, <span class="token number">0x0</span>        jne int_to_str        jmp print</code></pre><p>这里我们把0放入rdx，10放入rbx。然后我们执行除以rbx。如果我们在str_to_int调用之前查看上面的代码。我们将看到rax包含两个命令行参数的整数和。通过这个指令，我们将rax值除以rbx值，并在rdx中得到提醒，在rax中得到整个部分。接下来我们添加到rdx 48和0x0。在添加48之后，我们将得到这个数字的asci符号，所有字符串都以0x0结尾。在此之后，我们将符号保存到堆栈中，增量r12（在第一次迭代时为0，在开始时设置为0）并将rax与0进行比较，如果是0，则意味着我们结束将整数转换为字符串。算法的一步一步如下：例如我们有23</p><p>Here we put 0 to rdx and 10 to rbx. Than we exeute div rbx. If we look above at code before str_to_int call. We will see that rax contains integer number - sum of two command line arguments. With this instruction we devide rax value on rbx value and get reminder in rdx and whole part in rax. Next we add to rdx 48 and 0x0. After adding 48 we’ll get asci symbol of this number and all strings much be ended with 0x0. After this we save symbol to stack, increment r12 (it’s 0 at first iteration, we set it to 0 at the _start) and compare rax with 0, if it is 0 it means that we ended to convert integer to string. Algorithm step by step is following: For example we have number 23</p><pre class=" language-nasm"><code class="language-nasm">    <span class="token number">123</span> <span class="token operator">/</span> <span class="token number">10</span>. <span class="token register variable">rax</span> <span class="token operator">=</span> <span class="token number">12</span><span class="token comment" spellcheck="true">; rdx = 3</span>    <span class="token register variable">rdx</span> <span class="token operator">+</span> <span class="token number">48</span> <span class="token operator">=</span> <span class="token string">"3"</span>    push <span class="token string">"3"</span> to stack    compare <span class="token register variable">rax</span> with <span class="token number">0</span> if no go again    <span class="token number">12</span> <span class="token operator">/</span> <span class="token number">10</span>. <span class="token register variable">rax</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token comment" spellcheck="true">; rdx = 2</span>    <span class="token register variable">rdx</span> <span class="token operator">+</span> <span class="token number">48</span> <span class="token operator">=</span> <span class="token string">"2"</span>    push <span class="token string">"2"</span> to stack    compare <span class="token register variable">rax</span> with <span class="token number">0</span>, if yes we can finish function execution and we will have <span class="token string">"2"</span> <span class="token string">"3"</span> ... in stack</code></pre><p>我们实现了两个有用的函数int_to_str和str_to_int，用于将整数转换为字符串，反之亦然。现在我们有两个整数的和，它们被转换成字符串并保存在堆栈中。我们可以打印结果：</p><p>We implemented two useful function <code>int_to_str</code> and <code>str_to_int</code> for converting integer number to string and vice versa. Now we have sum of two integers which was converted into string and saved in the stack. We can print result:</p><pre class=" language-nasm"><code class="language-nasm"><span class="token label function">print:</span>    <span class="token comment" spellcheck="true">;;;; calculate number length</span>    mov <span class="token register variable">rax</span>, <span class="token number">1</span>    mul <span class="token register variable">r12</span>    mov <span class="token register variable">r12</span>, <span class="token number">8</span>    mul <span class="token register variable">r12</span>    mov <span class="token register variable">rdx</span>, <span class="token register variable">rax</span>    <span class="token comment" spellcheck="true">;;;; print sum</span>    mov <span class="token register variable">rax</span>, SYS_WRITE    mov <span class="token register variable">rdi</span>, STD_IN    mov <span class="token register variable">rsi</span>, <span class="token register variable">rsp</span>    <span class="token comment" spellcheck="true">;; call sys_write</span>    syscalljmp exit</code></pre><p>我们已经知道如何用sys_write syscall打印字符串，但这里有一个有趣的部分。我们必须计算字符串的长度。如果您查看int_to_str，您将看到我们每次迭代都递增r12寄存器，因此它包含我们的字符串的字数。我们必须将它乘以8（因为我们将每个符号都推到堆栈中）,它将是需要打印字符串的长度。在这之后，我们每次都把1放在rax（sys_write number）、1放在rdi（stdin）、字符串长度放在rdx和指向栈顶的指针放在rsi（start of string）上。完成我们的程序：</p><p>We already know how to print string with <code>sys_write</code> syscall, but here is one interesting part. We must to calculate length of string. If you will look on the <code>int_to_str</code>, you will see that we increment r12 register every iteration, so it contains amount of digits in our number. We must multiple it to 8 (because we pushed every symbol to stack) and it will be length of our string which need to print. After this we as everytime put 1 to rax (sys_write number), 1 to rdi (stdin), string length to rdx and pointer to the top of stack to rsi (start of string). And finish our program:</p><pre class=" language-nasm"><code class="language-nasm"><span class="token label function">exit:</span>    mov <span class="token register variable">rax</span>, SYS_EXIT    exit code    mov <span class="token register variable">rdi</span>, EXIT_CODE    syscall</code></pre><p>就这些了!</p><p>That’s all.</p>]]></content>
      
      
      
        <tags>
            
            <tag> x86 </tag>
            
            <tag> x64 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Say hello to x86_64 Assembly [part 2]</title>
      <link href="/2020/01/09/say-hello-to-x86-64-assembly-part-2/"/>
      <url>/2020/01/09/say-hello-to-x86-64-assembly-part-2/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/0xAX/asm" target="_blank" rel="noopener">翻译原文地址</a></p><h3 id="Say-hello-to-x86-64-Assembly-part-2"><a href="#Say-hello-to-x86-64-Assembly-part-2" class="headerlink" title="Say hello to x86_64 Assembly [part 2]"></a>Say hello to x86_64 Assembly [part 2]</h3><p>几天前，我写了第一篇博文-介绍x64汇编-<a href="">Say hello to x64 Assembly [part 1]</a>，出乎我的意料，引起了极大的兴趣：</p><p>Some days ago I wrote the first blog post - introduction to x64 assembly - Say hello to x64 Assembly [part 1] which to my surprise caused great interest:</p><p>它更激励我去描述我的学习方式。在这段时间里，我从不同的人那里得到了很多反馈。有很多感激的话，但对我来说更重要的是，有很多建议和批评。特别是我想对你的反馈说声谢谢：</p><p>It motivates me even more to describe my way of learning. During this days I got many feedback from different people. There were many grateful words, but what is more important for me, there were many advices and adequate critics. Especially I want to say thank you words for great feedback to:</p><ul><li><a href="http://www.reddit.com/user/Fiennes" target="_blank" rel="noopener">Fiennes</a></li><li><a href="https://disqus.com/by/Universal178/" target="_blank" rel="noopener">Grienders</a></li><li><a href="https://news.ycombinator.com/user?id=nkurz" target="_blank" rel="noopener">nkurz</a></li></ul><p>以及所有参与Reddit和Hacker News讨论的人。有很多意见，第一部分对初学者来说不是很清楚，这就是为什么我决定写更多信息性的文章。所以，让我们从Say hello to x86_64 assembly的第二部分开始。</p><p>And all who took a part in discussion at Reddit and Hacker News. There were many opinions, that first part was a not very clear for absolute beginner, that’s why i decided to write more informative posts. So, let’s start with second part of Say hello to x86_64 assembly.</p><h4 id="术语和概念"><a href="#术语和概念" class="headerlink" title="术语和概念"></a>术语和概念</h4><p>Terminology and Concepts</p><p>正如我在上面写的，我从不同的人那里得到了很多反馈，第一篇文章的某些部分并不是很清楚，这就是为什么让我们从描述一些术语开始，我们将在这一部分和下一部分看到这些术语。</p><p>As i wrote above, I got many feedback from different people that some parts of first post are not clear, that’s why let’s start from description of some terminology that we will see in this and next parts.</p><p>寄存器-寄存器是处理器内部的小批量的存储。处理器的核心是数据处理。处理器可以从内存中获取数据，但运行缓慢。这就是为什么处理器有自己的内部受限制的数据存储集，其名称叫-register(寄存器)。</p><p>Register - register is a small amount of storage inside processor. Main point of processor is data processing. Processor can get data from memory, but it is slow operation. That’s why processor has own internal restricted set of data storage which name is - register.</p><p>小端-我们可以把内存想象成一个大数组。它包含字节。每个地址存储内存“array”的一个元素。每个元素都是一个字节。例如，我们有4个字节：AA 56 AB FF。在小端数据中，最低有效字节的地址最小：</p><p>Little-endian - we can imagine memory as one large array. It contains bytes. Each address stores one element of the memory “array”. Each element is one byte. For example we have 4 bytes: AA 56 AB FF. In little-endian the least significant byte has the smallest address:</p><pre><code>    0 FF    1 AB    2 56    3 AA</code></pre><p>其中0、1、2和3是内存地址。<br>大端-大端以与小端相反的顺序存储字节。所以如果我们有一个56 AB FF字节的序列，它将是：</p><p>where 0,1,2 and 3 are memory addresses.</p><p>Big-endian - big-endian stores bytes in opposite order than little-endian. So if we have AA 56 AB FF bytes sequence it will be:</p><pre><code>    0 AA    1 56    2 AB    3 FF</code></pre><p>Syscall是一个用户级程序要求操作系统为它做一些事情的方式。您可以在这里找到<a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl" target="_blank" rel="noopener">syscall表</a>。<br>堆栈 - 处理器的寄存器数量非常有限,所以堆栈是内存可寻址的特殊寄存器RSP、SS、RIP等组成的一个连续区域。我们将在下一部分对堆栈进行更深入的研究。</p><p>Syscall - is the way a user level program asks the operating system to do something for it. You can find <a href="https://github.com/torvalds/linux/blob/master/arch/x86/entry/syscalls/syscall_64.tbl" target="_blank" rel="noopener">syscall table - here</a>.</p><p>Stack - processor has a very restricted count of registers. So stack is a continuous area of memory addressable special registers RSP,SS,RIP and etc. We will take a closer look on stack in next parts.</p><p>节-每个汇编程序都由节组成。有以下部分：</p><ul><li>data-段用于声明初始化的数据或常量</li></ul><ul><li>bss-段用于声明未初始化的变量</li></ul><ul><li>Text-段用于代码</li></ul><p>Section - every assembly program consists from sections. There are following sections:</p><ul><li><code>data</code> - section is used for declaring initialized data or constants</li><li><code>bss</code> - section is used for declaring non initialized variables</li><li><code>text</code> - section is used for code</li></ul><p>通用寄存器有16个-rax、rbx、rcx、rdx、rbp、rsp、rsi、rdi、r8、r9、r10、r11、r12、r13、r14、r15。当然，它并不是一个完整的与汇编编程相关的术语和概念列表。如果我们在下一篇博文中遇到另一个陌生和不熟悉的词，会有对这些词的解释。</p><p>General-purpose registers - there are 16 general-purpose registers - rax, rbx, rcx, rdx, rbp, rsp, rsi, rdi, r8, r9, r10, r11, r12, r13, r14, r15. Of course, it is not a full list of terms and concepts which related with assembly programming. If we will meet another strange and unfamiliar words in next blog posts, there will be explanation of this words.</p><h4 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h4><p>Data Types</p><p>基本数据类型是字节、字、双字、四字和双四字。一个字节是8比特位，一个字是2个字节位，一个双字是4个字节位，一个四字是8个字节位，一个双四字是16个字节位（128位）。</p><p>The fundamental data types are bytes, words, doublewords, quadwords, and double quadwords. A byte is eight bits, a word is 2 bytes, a doubleword is 4 bytes, a quadword is 8 bytes and a double quadword is 16 bytes (128 bits).</p><p>现在我们只处理整数，所以让我们来看看。整数有两种类型：无符号整数和有符号整数。无符号整数是包含在字节、字、双字和四字中的无符号二进制数。无符号字节整数的值范围为0到255，无符号字整数的值范围为0到65535，无符号双字整数的值范围为0到2^32–1，无符号四字整数的值范围为0到2^64–1。有符号整数是在字节、字等中作为无符号保存的有符号二进制数。符号位设置为负整数，清除为正整数和零。整数值的范围从-128到+127（字节整数），从-32768到+32767（字整数），从-2^31到+2^31–1（双字整数），从-2^63到+2^63–1（四字整数）。</p><p>Now we will work only with integer numbers, so let’s see to it. There two types of integer: unsigned and signed. Unsigned integers are unsigned binary numbers contained in a byte, word, doubleword, and quadword. Their values range from 0 to 255 for an unsigned byte integer, from 0 to 65,535 for an unsigned word integer, from 0 to 2^32 – 1 for an unsigned doubleword integer, and from 0 to 2^64 – 1 for an unsigned quadword integer. Signed integers are signed binary numbers held as unsigned in a byte, word and etc… The sign bit is set for negative integers and cleared for positive integers and zero. Integer values range from –128 to +127 for a byte integer, from –32,768 to +32,767 for a word integer,from –2^31 to +2^31 – 1 for a doubleword integer, and from –2^63 to +2^63 – 1 for a quadword integer.</p><h4 id="节"><a href="#节" class="headerlink" title="节"></a>节</h4><p>Sections</p><p>如上所述，每个汇编程序都由段组成，可以是数据部分、文本部分和bss部分。让我们看看数据部分，它是声明初始化常量的要地点。例如：</p><p>As i wrote above, every assembly program consists from sections, it can be data section, text section and bss section. Let’s look on data section.It’s main point - to declare initialized constants. For example:</p><pre class=" language-nasm"><code class="language-nasm"><span class="token keyword">section .data</span>    <span class="token label function">num1:</span>   equ <span class="token number">100</span>    <span class="token label function">num2:</span>   equ <span class="token number">50</span>    <span class="token label function">msg:</span>    db <span class="token string">"Sum is correct"</span>, <span class="token number">10</span></code></pre><p>好的，这里几乎都清楚了。3个名为num1、num2、msg的常量，值为100、50和“Sum is correct”，10。但是什么是db，equ？实际是NASM支持许多伪指令之一：</p><p>Ok, it is almost all clear here. 3 constants with name num1, num2, msg and with values 100, 50 and “Sum is correct”, 10. But what is it db, equ? Actual NASM supports a number of pseudo-instructions:</p><ul><li><p>DB、DW、DD、DQ、DT、DO、DY和DZ-用于声明初始化数据。例如：</p></li><li><p>DB, DW, DD, DQ, DT, DO, DY and DZ - are used for declaring initialized data. For example:</p></li></ul><pre class=" language-nasm"><code class="language-nasm"><span class="token comment" spellcheck="true">;; Initialize 4 bytes 1h, 2h, 3h, 4h</span>db <span class="token number">0x01</span>,<span class="token number">0x02</span>,<span class="token number">0x03</span>,<span class="token number">0x04</span><span class="token comment" spellcheck="true">;; Initialize word to 0x12 0x34</span>dw    <span class="token number">0x1234</span></code></pre><ul><li><p>RESB, RESW, RESD, RESQ, REST, RESO, RESY and RESZ -用于声明未初始化的变量</p></li><li><p>INCBIN - 包含外部二进制文件</p></li><li><p>EQU - 定义常量。例如：</p></li><li><p>RESB, RESW, RESD, RESQ, REST, RESO, RESY and RESZ - are used for declaring non initialized variables</p></li><li><p>INCBIN - includes External Binary Files</p></li><li><p>EQU - defines constant. For example:</p></li></ul><pre class=" language-nasm"><code class="language-nasm"><span class="token comment" spellcheck="true">;; now one is 1</span>one equ <span class="token number">1</span></code></pre><p>TIMES - 重复的指令或数据。（描述将在下一篇文章中）</p><p>TIMES - Repeating Instructions or Data. (description will be in next posts)</p><h4 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h4><p>Arithmetic operations</p><p>下面是算术指令的简短列表：</p><ul><li><code>ADD</code> - 整数加法</li><li><code>SUB</code> - 减法</li><li><code>MUL</code> - 无符号乘法</li><li><code>IMUL</code> - 有符号乘法</li><li><code>DIV</code> - 无符号除法</li><li><code>IDIV</code> - 有符号除法</li><li><code>INC</code> - 递增</li><li><code>DEC</code> - 递减</li><li><code>NEG</code> - 求补运算</li></ul><p>我们将在这篇文章的练习中看到其中的一些。其他将在下一篇文章中讨论。</p><p>There is short list of arithmetic instructions:</p><ul><li><code>ADD</code> - integer add</li><li><code>SUB</code> - substract</li><li><code>MUL</code> - unsigned multiply</li><li><code>IMUL</code> - signed multiply</li><li><code>DIV</code> - unsigned divide</li><li><code>IDIV</code> - signed divide</li><li><code>INC</code> - increment</li><li><code>DEC</code> - decrement</li><li><code>NEG</code> - negate</li></ul><p>Some of it we will see at practice in this post. Other will be covered in next posts.</p><h4 id="控制流"><a href="#控制流" class="headerlink" title="控制流"></a>控制流</h4><p>Control flow</p><p>通常编程语言能够改变求值顺序（使用if语句、case语句、goto等），而汇编语言也有这种能力。在这里我们将看到一些。cmp指令用于执行两个值之间的比较。它与条件跳转指令一起用于决策。例如：</p><p>Usually programming languages have ability to change order of evaluation (with if statement, case statement, goto and etc…) and assembly has it too. Here we will see some of it. There is cmp instruction for performing comparison between two values. It is used along with the conditional jump instruction for decision making. For example:</p><pre class=" language-nasm"><code class="language-nasm"><span class="token comment" spellcheck="true">;; compare rax with 50</span>cmp <span class="token register variable">rax</span>, <span class="token number">50</span></code></pre><p>cmp指令只比较两个值，但不会影响它们，也不会根据比较结果执行任何操作。对于比较后执行的任何操作，都有条件跳转指令。它可以是下面的其中之一：</p><p>The <code>cmp</code> instruction just compares 2 values, but doesn’t affect them and doesn’t execute anything depend on result of comparison. For performing any actions after comparison there is conditional jump instructions. It can be one of it:</p><ul><li><code>JE</code> - 如果相等</li><li><code>JZ</code> - 如果为零</li><li><code>JNE</code> - 如果不相等</li><li><code>JNZ</code> - 如果不为零</li><li><code>JG</code> - 如果第一个操作数大于第二个操作数</li><li><code>JGE</code> - 如果第一个操作数大于或等于第二个操作数</li><li><code>JA</code> - 与JG相同，但执行无符号比较</li><li><code>JAE</code> - 与JGE相同，但执行无符号比较</li></ul><ul><li><code>JE</code> - if equal</li><li><code>JZ</code> - if zero</li><li><code>JNE</code> - if not equal</li><li><code>JNZ</code> - if not zero</li><li><code>JG</code> - if first operand is greater than second</li><li><code>JGE</code> - if first operand is greater or equal to second</li><li><code>JA</code> - the same that JG, but performs unsigned comparison</li><li><code>JAE</code> - the same that JGE, but performs unsigned comparison</li></ul><p>例如，如果我们想在C中生成类似if/else的语句：</p><p>For example if we want to make something like if/else statement in C:</p><pre class=" language-c"><code class="language-c"><span class="token keyword">if</span> <span class="token punctuation">(</span>rax <span class="token operator">!=</span> <span class="token number">50</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">exit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">right</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在汇编中:</p><p>will be in assembly:</p><pre class=" language-nasm"><code class="language-nasm"><span class="token comment" spellcheck="true">;; compare rax with 50</span>cmp <span class="token register variable">rax</span>, <span class="token number">50</span><span class="token comment" spellcheck="true">;; perform .exit if rax is not equal 50</span>jne .exitjmp .right</code></pre><p>还有无条件跳转语法：</p><p>There is also unconditional jump with syntax:</p><pre class=" language-nasm"><code class="language-nasm">JMP label</code></pre><p>例子</p><pre class=" language-nasm"><code class="language-nasm"><span class="token label function">_start:</span>    <span class="token comment" spellcheck="true">;; ....</span>    <span class="token comment" spellcheck="true">;; do something and jump to .exit label</span>    <span class="token comment" spellcheck="true">;; ....</span>    jmp .exit<span class="token label function">.exit:</span>    mov    <span class="token register variable">rax</span>, <span class="token number">60</span>    mov    <span class="token register variable">rdi</span>, <span class="token number">0</span>    syscall</code></pre><p>在这里我们可以有一些代码在开始标签之后，所有这些代码将被执行，汇编转移控制指令到.Excel标签和代码之后。退出代码将开始执行。</p><p>Here we have can have some code which will be after _start label, and all of this code will be executed, assembly transfer control to .exit label, and code after .exit: will start to execute.</p><p>在循环中经常使用无条件跳转。例如，我们有标签和一些代码。此代码执行的任何操作，如果条件不成功，则跳转到此代码的开头。循环将在下一部分中介绍。</p><p>Often unconditional jump uses in loops. For example we have label and some code after it. This code executes anything, than we have condition and jump to the start of this code if condition is not successfully. Loops will be covered in next parts.</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>Example</p><p>让我们看一个简单的例子。它将取两个整数，得到这些数的和，并与预定义的数进行比较。如果预定义的数等于两个整数的和，那么它将在屏幕上打印一些东西，如果不是的话，只需退出即可。下面是我们示例的源代码：</p><p>Let’s see simple example. It will take two integer numbers, get sum of these numbers and compare it with predefined number. If predefined number is equal to sum, it will print something on the screen, if not - just exit. Here is the source code of our example:</p><pre class=" language-nasm"><code class="language-nasm"><span class="token keyword">section .data</span>    <span class="token comment" spellcheck="true">; Define constants</span>    <span class="token label function">num1:</span>   equ <span class="token number">100</span>    <span class="token label function">num2:</span>   equ <span class="token number">50</span>    <span class="token comment" spellcheck="true">; initialize message</span>    <span class="token label function">msg:</span>    db <span class="token string">"Sum is correct\n"</span><span class="token keyword">section .text</span>    <span class="token keyword">global _start</span><span class="token comment" spellcheck="true">;; entry point</span><span class="token label function">_start:</span>    <span class="token comment" spellcheck="true">; set num1's value to rax</span>    mov <span class="token register variable">rax</span>, num1    <span class="token comment" spellcheck="true">; set num2's value to rbx</span>    mov <span class="token register variable">rbx</span>, num2    <span class="token comment" spellcheck="true">; get sum of rax and rbx, and store it's value in rax</span>    add <span class="token register variable">rax</span>, <span class="token register variable">rbx</span>    <span class="token comment" spellcheck="true">; compare rax and 150</span>    cmp <span class="token register variable">rax</span>, <span class="token number">150</span>    <span class="token comment" spellcheck="true">; go to .exit label if rax and 150 are not equal</span>    jne .exit    <span class="token comment" spellcheck="true">; go to .rightSum label if rax and 150 are equal</span>    jmp .rightSum<span class="token comment" spellcheck="true">; Print message that sum is correct</span><span class="token label function">.rightSum:</span>    <span class="token comment" spellcheck="true">;; write syscall</span>    mov     <span class="token register variable">rax</span>, <span class="token number">1</span>    <span class="token comment" spellcheck="true">;; file descritor, standard output</span>    mov     <span class="token register variable">rdi</span>, <span class="token number">1</span>    <span class="token comment" spellcheck="true">;; message address</span>    mov     <span class="token register variable">rsi</span>, msg    <span class="token comment" spellcheck="true">;; length of message</span>    mov     <span class="token register variable">rdx</span>, <span class="token number">15</span>    <span class="token comment" spellcheck="true">;; call write syscall</span>    syscall    <span class="token comment" spellcheck="true">; exit from program</span>    jmp .exit<span class="token comment" spellcheck="true">; exit procedure</span><span class="token label function">.exit:</span>    <span class="token comment" spellcheck="true">; exit syscall</span>    mov    <span class="token register variable">rax</span>, <span class="token number">60</span>    <span class="token comment" spellcheck="true">; exit code</span>    mov    <span class="token register variable">rdi</span>, <span class="token number">0</span>    <span class="token comment" spellcheck="true">; call exit syscall</span>    syscall</code></pre><p>让我们看看源代码。首先有两个常数num1、num2和变量msg的数据段，其值为“Sum is correct\n”。现在看14行。有程序开始的入口点。我们将num1和num2值传输到通用寄存器rax和rbx。用加法指令求和。在执行add指令后，它计算rax和rbx的值之和，并将其值存储到rax。现在我们有了rax寄存器中num1和num2的和。</p><p>Let’s go through the source code. First of all there is data section with two constants num1, num2 and variable msg with “Sum is correct\n” value. Now look at 14 line. There is begin of program’s entry point. We transfer num1 and num2 values to general purpose registers rax and rbx. Sum it with add instruction. After execution of add instruction, it calculates sum of values from rax and rbx and store it’s value to rax. Now we have sum of num1 and num2 in the rax register.</p><p>好的，我们有值为100的num1和值为50的num2。我们的总数必须是150。让我们用cmp指令检查一下。在比较RAX和150之后，我们检查比较的结果，如果RAX和150不相等（用JNE检查），我们去.exit标签，如果它们相等，我们去.rightSum标签。</p><p>Ok we have num1 which is 100 and num2 which is 50. Our sum must be 150. Let’s check it with cmp instruction. After comparison rax and 150 we check result of comparison, if rax and 150 are not equal (checking it with jne) we go to .exit label, if they are equal we go to .rightSum label.</p><p>现在我们有两个标签：.exit和.rightSum。首先是设置60到rax，它是退出系统的调用码，0是rdi，它是一个退出码。第二个是.rightSum ,非常简单，它只是打印出”Sum is correct”。</p><p>Now we have two labels: .exit and .rightSum. First is just sets 60 to rax, it is exit system call number, and 0 to rdi, it is a exit code. Second is .rightSum is pretty easy, it just prints Sum is correct.</p>]]></content>
      
      
      
        <tags>
            
            <tag> x86 </tag>
            
            <tag> x64 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>android 常用命令记录</title>
      <link href="/2020/01/08/adb-chang-yong-ming-ling-ji-lu/"/>
      <url>/2020/01/08/adb-chang-yong-ming-ling-ji-lu/</url>
      
        <content type="html"><![CDATA[<h3 id="android-常用命令记录"><a href="#android-常用命令记录" class="headerlink" title="android 常用命令记录"></a>android 常用命令记录</h3><h5 id="1-adb-shell-dumpsys-meminfo"><a href="#1-adb-shell-dumpsys-meminfo" class="headerlink" title="1.adb shell dumpsys meminfo"></a>1.adb shell dumpsys meminfo</h5><p>查看指定金正名称或者进程id对应的内存信息,这个一般情况我们都是用来获取内存相关信息的</p><p>例子：adb shell dumpsys meminfo [packageName/PID]</p><p>adb shell dumpsys meminfo com.tencent.mm</p><pre><code>    115881 kB:  112332 kB: com.tencent.mm (pid 26335 / activities)     87806 kB:  63520 kB: com.tencent.mm (pid 24519)</code></pre><h5 id="2-adb-shell-dumpsys-dbinfo-com-temcent-mm"><a href="#2-adb-shell-dumpsys-dbinfo-com-temcent-mm" class="headerlink" title="2.adb shell dumpsys dbinfo com.temcent.mm"></a>2.adb shell dumpsys dbinfo com.temcent.mm</h5><p>查看指定报名应用的数据库信息</p><h5 id="3-adb-install-r-apk"><a href="#3-adb-install-r-apk" class="headerlink" title="3.adb install -r [apk]"></a>3.adb install -r [apk]</h5><p>安装apk软件，-r替换掉原有的，覆盖安装</p><h5 id="4-adb-uninstall-apk"><a href="#4-adb-uninstall-apk" class="headerlink" title="4.adb uninstall [apk]"></a>4.adb uninstall [apk]</h5><p>卸载apk软件</p><h5 id="5-adb-shell-screencap"><a href="#5-adb-shell-screencap" class="headerlink" title="5.adb shell screencap"></a>5.adb shell screencap</h5><p>截取屏幕</p><p>例子：adb shell screencap -p /mnt/sdcard/1.png</p><h5 id="5-adb-shell-screenrecord"><a href="#5-adb-shell-screenrecord" class="headerlink" title="5.adb shell screenrecord"></a>5.adb shell screenrecord</h5><p>录制屏幕</p><h5 id="6-adb-shell-input-text-文本内容"><a href="#6-adb-shell-input-text-文本内容" class="headerlink" title="6.adb shell input text [文本内容]"></a>6.adb shell input text [文本内容]</h5><p>输入文本内容</p><p>例子:adb shell input text ‘Hello world’</p><p>这个命令也可以模拟物理按键，虚拟键盘，滑动，滚动等事件。</p><h5 id="7-adb-forward"><a href="#7-adb-forward" class="headerlink" title="7.adb forward"></a>7.adb forward</h5><p>设备的端口转发</p><p> adb forward [远程端协议：端口号] [设备端协议:端口号]</p><p>ida调试的时候会经常用到</p><h5 id="8-adb-jdwp"><a href="#8-adb-jdwp" class="headerlink" title="8.adb jdwp"></a>8.adb jdwp</h5><p>查看设备中可以被调试的应用程序进程号</p><h5 id="9-adb-logcat"><a href="#9-adb-logcat" class="headerlink" title="9.adb logcat"></a>9.adb logcat</h5><p>查看当前日志信息</p><p>adb shell logcat |grep com.temcemt.mm</p><h5 id="10-adb-shell-pm-clear-packagename"><a href="#10-adb-shell-pm-clear-packagename" class="headerlink" title="10.adb  shell pm clear [packagename]"></a>10.adb  shell pm clear [packagename]</h5><p>清空应用数据</p><h5 id="11-am-start-n-packagename-packagename-acitivity"><a href="#11-am-start-n-packagename-packagename-acitivity" class="headerlink" title="11.am start -n [packagename/packagename.acitivity]"></a>11.am start -n [packagename/packagename.acitivity]</h5><p>启动对应的acitivty</p><p>加入-D 参数可以使用debug方式启动</p><h5 id="12-aapt-获取apk信息"><a href="#12-aapt-获取apk信息" class="headerlink" title="12.aapt 获取apk信息"></a>12.aapt 获取apk信息</h5><p>apt dump xmltree demo.apk AndroidManifest.xml &gt;1.txt</p><p>通过命令，把获取到信息重定向到1.txt文件里面</p><h5 id="13-dexdump"><a href="#13-dexdump" class="headerlink" title="13 .dexdump"></a>13 .dexdump</h5><p>dexdump [dex文件名]</p><p>查看dex文件的详细信息</p><h5 id="14-cat-proc-pid-maps"><a href="#14-cat-proc-pid-maps" class="headerlink" title="14.cat /proc/[pid]/maps"></a>14.cat /proc/[pid]/maps</h5><p>使用cat命令查看对应pid的内存映射信息,比如加载了哪些so文件，dex文件等等</p><h5 id="15-cat-proc-pid-status"><a href="#15-cat-proc-pid-status" class="headerlink" title="15.cat /proc/[pid]/status"></a>15.cat /proc/[pid]/status</h5><p>查看进程对应的状态信息,例如 TracerPid</p><h5 id="16-获取当前端口号信息"><a href="#16-获取当前端口号信息" class="headerlink" title="16.获取当前端口号信息"></a>16.获取当前端口号信息</h5><p>cat /proc/[pid]/net/tcp | tcp6 | udp | udp6</p><h5 id="17-odex反编译成smali"><a href="#17-odex反编译成smali" class="headerlink" title="17.odex反编译成smali"></a>17.odex反编译成smali</h5><pre class=" language-shell"><code class="language-shell">java -jar baksmali.jar x services.odex</code></pre><p>反编译odex的过程中会报很多错误，原因都是缺少依赖，缺少什么依赖，我们就将它从手机pull出来，并放在 services.odex同级目录下，等到不缺依赖的时候，反编译也就能完成了。</p><h5 id="18-smali转成Dex"><a href="#18-smali转成Dex" class="headerlink" title="18.smali转成Dex"></a>18.smali转成Dex</h5><pre class=" language-shell"><code class="language-shell">java -jar smali.jar as out/ -a 28 -o services.dex</code></pre><h5 id="19-dex2oat工具将dex转换成odex"><a href="#19-dex2oat工具将dex转换成odex" class="headerlink" title="19.dex2oat工具将dex转换成odex"></a>19.dex2oat工具将dex转换成odex</h5><pre class=" language-shell"><code class="language-shell">adb push services.dex /data/local/tmp/services.dexadb shellexport ANDROID_DATA=/dataexport ANDROID_ROOT=/systemdex2oat --dex-file=/data/local/tmp/services.dex --oat-file=/data/local/tmp/services.odex  --instruction-set=arm64 --runtime-arg -Xms64m --runtime-arg -Xmx128m</code></pre><h5 id="20-readelf-使用"><a href="#20-readelf-使用" class="headerlink" title="20.readelf 使用"></a>20.readelf 使用</h5><p>readelf -h hello.o 获取elf文件头信息</p><pre class=" language-shell"><code class="language-shell">ELF 头：  Magic：   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00   类别:                              ELF64  数据:                              2 补码，小端序 (little endian)  Version:                           1 (current)  OS/ABI:                            UNIX - System V  ABI 版本:                          0  类型:                              REL (可重定位文件)  系统架构:                          Advanced Micro Devices X86-64  版本:                              0x1  入口点地址：               0x0  程序头起点：          0 (bytes into file)  Start of section headers:          64 (bytes into file)  标志：             0x0  Size of this header:               64 (bytes)  Size of program headers:           0 (bytes)  Number of program headers:         0  Size of section headers:           64 (bytes)  Number of section headers:         7  Section header string table index: 3</code></pre><p>readelf -l hello.so 查看程序段头信息</p><pre class=" language-shell"><code class="language-shell">Elf 文件类型为 DYN (共享目标文件)Entry point 0x0There are 8 program headers, starting at offset 64程序头：  Type           Offset             VirtAddr           PhysAddr                 FileSiz            MemSiz              Flags  Align  PHDR           0x0000000000000040 0x0000000000000040 0x0000000000000040                 0x00000000000001c0 0x00000000000001c0  R      0x8  LOAD           0x0000000000000000 0x0000000000000000 0x0000000000000000                 0x000000000000e204 0x000000000000e204  R E    0x10000  LOAD           0x000000000000fcf0 0x000000000001fcf0 0x000000000001fcf0                 0x0000000000000bd0 0x0000000000001308  RW     0x10000  DYNAMIC        0x000000000000fd08 0x000000000001fd08 0x000000000001fd08                 0x0000000000000250 0x0000000000000250  RW     0x8  NOTE           0x0000000000000200 0x0000000000000200 0x0000000000000200                 0x0000000000000020 0x0000000000000020  R      0x4  GNU_EH_FRAME   0x000000000000def8 0x000000000000def8 0x000000000000def8                 0x000000000000030c 0x000000000000030c  R      0x4  GNU_STACK      0x0000000000000000 0x0000000000000000 0x0000000000000000                 0x0000000000000000 0x0000000000000000  RW     0x10  GNU_RELRO      0x000000000000fcf0 0x000000000001fcf0 0x000000000001fcf0                 0x0000000000000310 0x0000000000000310  RW     0x8 Section to Segment mapping:  段节...   00        01     .note.gnu.build-id .dynsym .dynstr .gnu.hash .hash .gnu.version .gnu.version_d .gnu.version_r .rela.dyn .rela.plt .plt .text .rodata .eh_frame .eh_frame_hdr    02     .fini_array .init_array .dynamic .got .got.plt .data .bss    03     .dynamic    04     .note.gnu.build-id    05     .eh_frame_hdr    06        07     .fini_array .init_array .dynamic .got .got.plt </code></pre><p>readelf -a hello.so 查看全部信息</p><h5 id="21-chmod命令"><a href="#21-chmod命令" class="headerlink" title="21.chmod命令"></a>21.chmod命令</h5><p>9  8  7  6  5  4  3  2  1  0</p><p>从左到右分别为9-0</p><p>第9位表示文件类型，可以设置的值为p,d,l,s,c,b和-</p><p>p表示命名管道文件</p><p>d表示目录</p><p>l表示符号链接文件</p><p>s表示socket文件</p><p>c表示字符设备文件</p><p>b表示块设备文件</p><p>-表示普通文件</p><p>第8<del>6 位，5</del>3位，2~0位分别表示文件所有者的权限，同组用户的权限，其他用户权限，取值位rwx</p><p>r表示读，可以读取文件内容，对应数字是4</p><p>w表示写，可以修改文件内容，对应的数字是2</p><p>x表示可以执行，可运行这个程序，对应的数字是1</p><pre class=" language-shell"><code class="language-shell">chmod u=rwx,g=r,o=x filename</code></pre><p>u代表所有者，g代表组用户，o代表其他用户</p><h5 id="22-aapt-dump-AndroidManifest-xml-文件内容"><a href="#22-aapt-dump-AndroidManifest-xml-文件内容" class="headerlink" title="22.aapt dump AndroidManifest.xml 文件内容"></a>22.aapt dump AndroidManifest.xml 文件内容</h5><pre class=" language-shell"><code class="language-shell">aapt dump xmltree applock.apk AndroidManifest.xml > /home/jack/xml.txt</code></pre><h5 id="23-使用signapk-jar签名"><a href="#23-使用signapk-jar签名" class="headerlink" title="23.使用signapk.jar签名"></a>23.使用signapk.jar签名</h5><pre class=" language-bash"><code class="language-bash">java -jar signapk.jar textkey.x509.pem testkey.pk8 debug.apk debug.sig.apk</code></pre><p>pk8是私钥文件</p><p>x509.pem是含有公钥的文件</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 常用命令 </tag>
            
            <tag> shell </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Say hello to x86_64 Assembly [part 1]</title>
      <link href="/2020/01/08/say-hello-to-x86-64-assembly-part-1/"/>
      <url>/2020/01/08/say-hello-to-x86-64-assembly-part-1/</url>
      
        <content type="html"><![CDATA[<p><a href="https://github.com/0xAX/asm" target="_blank" rel="noopener">翻译原文地址</a></p><h3 id="Say-hello-to-x86-64-Assembly-part-1"><a href="#Say-hello-to-x86-64-Assembly-part-1" class="headerlink" title="Say hello to x86_64 Assembly [part 1]"></a>Say hello to x86_64 Assembly [part 1]</h3><h5 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h5><p>Introduction</p><p>我们中间有很多开发者，我们每天写了成千上万行代码。有时候甚至是一些不错的代码：）我们每个人都能写出像下面这样的简单代码：</p><p>There are many developers between us. We write a tons of code every day. Sometime, it is even not a bad code :) Every of us can easily write the simplest code like this:</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>  <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"x + y = %d"</span><span class="token punctuation">,</span> x <span class="token operator">+</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>我们每个人都能明白这个c代码做了什么，但…这些代码在底层如何工作的？我相信不是我们所有人都能够回答这个问题，包括我。我认为我能写高级语言的代码，像Haskell, Erlang, Go 等等…,但我绝对不知道在汇编之后他们是如何在底层工作的。所以我决定去进一步深入了解汇编并描绘我的学习方式。希望他会是个很有趣的事情，不仅仅是对我。大概5-6年前，我已经开始使用汇编编写一些简单的程序了，那是我在大学里面，使用Turbo Assembly 和DOS系统。现在我使用Linux-x86-64 系统。是的，Linux 64位和DOS 16位系统有很大的区别。让我们开始吧。</p><p>Every of us can understand what’s this C code does. But… How this code works at low level? I think that not all of us can answer on this question, and me too. I thought that i can write code on high level programming languages like Haskell, Erlang, Go and etc…, but i absolutely don’t know how it works at low level, after compilation. So I decided to take a few deep steps down, to assembly, and to describe my learning way about this. Hope it will be interesting, not only for me. Something about 5 - 6 years ago I already used assembly for writing simple programs, it was in university and i used Turbo assembly and DOS operating system. Now I use Linux-x86-64 operating system. Yes, must be big difference between Linux 64 bit and DOS 16 bit. So let’s start.</p><h5 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h5><p>Preparation</p><p>在我们开始前，我必须准备一些东西，例如我使用的Ubuntu(Ubuntu 14.04.1 LTS 64 bit)，因此我写的文章将针对这个操作系统和架构。不同的CPU支持不同的指令集，我使用的是 Intel Core i7 870 处理器，所有的代码都将由这个处理器所编写。我将使用nasm汇编，你可以使用下面命令安装：</p><p>Before we started, we must to prepare some things like As I wrote about, I use Ubuntu (Ubuntu 14.04.1 LTS 64 bit), thus my posts will be for this operating system and architecture. Different CPU supports different set of instructions. I use Intel Core i7 870 processor, and all code will be written processor. Also i will use nasm assembly. You can install it with:</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">sudo</span> <span class="token function">apt-get</span> <span class="token function">install</span> nasm</code></pre><p>它的版本必须是2.0.0或者更高版本。我2013年12月29日编译的NASM版本是2.10.09。最后一部分，需要在文本编辑器中编写汇编代码。我使用Emacs配合nasm-mode.el来进行编写。当然你可以选择你喜欢的编辑器。如果你和我一样使用Emacs，你可以下载nasm-mode.el 并配置你的Emacs像这样：</p><p>It’s version must be 2.0.0 or greater. I use NASM version 2.10.09 compiled on Dec 29 2013 version. And the last part, you will need in text editor where you will write you assembly code. I use Emacs with nasm-mode.el for this. It is not mandatory, of course you can use your favourite text editor. If you use Emacs as me you can download nasm-mode.el and configure your Emacs like this:</p><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">(load</span> <span class="token attr-value">"~/.emacs.d/lisp/nasm.el")</span><span class="token attr-name">(require</span> <span class="token attr-value">'nasm-mode)</span><span class="token attr-name">(add-to-list</span> <span class="token attr-value">'auto-mode-alist '("\\.\\(asm\\|s\\)$" . nasm-mode))</span></code></pre><p>这就是我们现在所需要的。其他工具将在下一篇文章中描述。</p><p>That’s all we need for this moment. Other tools will be describe in next posts.</p><h5 id="nasm汇编的语法"><a href="#nasm汇编的语法" class="headerlink" title="nasm汇编的语法"></a>nasm汇编的语法</h5><p>Syntax of nasm assembly</p><p>在这里，我不会描述完整的汇编语法，我们将只提到我们在本文中使用到的部分语法。通常NASM程序分为几个部分。在本文中，我们将讨论以下两个部分：</p><p>Here I will not describe full assembly syntax, we’ll mention only those parts of the syntax, which we will use in this post. Usually NASM program divided into sections. In this post we’ll meet 2 following sections:</p><ul><li><p>数据段</p></li><li><p>文本段</p></li><li><p>data section</p></li><li><p>text section</p></li></ul><p>数据段用于声明常量。此数据在运行时不会更改。您可以声明各种数学或其他常量等。声明数据段的语法为：</p><p>The data section is used for declaring constants. This data does not change at runtime. You can declare various math or other constants and etc… The syntax for declaring data section is:</p><pre class=" language-nasm"><code class="language-nasm"><span class="token keyword">section .data</span> </code></pre><p>文本部分用于代码。本节必须以声明global-start开始，它告诉内核程序执行的开始位置。</p><p>The text section is for code. This section must begin with the declaration global _start, which tells the kernel where the program execution begins.</p><pre class=" language-nasm"><code class="language-nasm">    <span class="token keyword">section .text</span>    <span class="token keyword">global _start</span>    <span class="token label function">_start:</span></code></pre><p>注释以；符号开头。每个NASM源代码行都包含以下四个字段的某些组合：</p><p>Comments starts with the ; symbol. Every NASM source code line contains some combination of the following four fields:</p><pre class=" language-nasm"><code class="language-nasm"><span class="token operator">[</span>label:<span class="token operator">]</span> instruction <span class="token operator">[</span>operands<span class="token operator">]</span> <span class="token operator">[</span><span class="token comment" spellcheck="true">; comment]</span></code></pre><p>方括号中的字段是可选的。基本的NASM指令由两部分组成。第一个是要执行的指令的名称，第二个是这个命令的操作数。例如：</p><p>Fields which are in square brackets are optional. A basic NASM instruction consists from two parts. The first one is the name of the instruction which is to be executed, and the second are the operands of this command. For example:</p><pre class=" language-nasm"><code class="language-nasm">MOV COUNT, <span class="token number">48</span> <span class="token comment" spellcheck="true">; Put value 48 in the COUNT variable</span></code></pre><h5 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h5><p>Hello world</p><p>让我们用NASM汇编编写第一个程序。当然，这将是传统的Hello world程序。这是它的代码：</p><p>Let’s write first program with NASM assembly. And of course it will be traditional Hello world program. Here is the code of it:</p><pre class=" language-nasm"><code class="language-nasm"><span class="token keyword">section .data</span>    msg db      <span class="token string">"hello, world!"</span><span class="token keyword">section .text</span>    <span class="token keyword">global _start</span><span class="token label function">_start:</span>    mov     <span class="token register variable">rax</span>, <span class="token number">1</span>    mov     <span class="token register variable">rdi</span>, <span class="token number">1</span>    mov     <span class="token register variable">rsi</span>, msg    mov     <span class="token register variable">rdx</span>, <span class="token number">13</span>    syscall    mov    <span class="token register variable">rax</span>, <span class="token number">60</span>    mov    <span class="token register variable">rdi</span>, <span class="token number">0</span>    syscall</code></pre><p>是的，它看起来不像printf（“Hello world”）。让我们试着了解它是什么以及它是如何工作的。看1-2行。我们定义了data section并将msg常量与Hello world值放在一起。现在我们可以在代码中使用这个常量。接下来是声明文本段和程序入口点。程序将从7行开始执行。现在开始最有趣的部分。我们已经知道它是mov指令了，它有两个操作数，然后把值从第二个放到第一个。但这些rax，rdi…是什么,我们可以在维基百科上看到:</p><p>Yes, it doesn’t look like printf(“Hello world”). Let’s try to understand what is it and how it works. Take a look 1-2 lines. We defined data section and put there msg constant with Hello world value. Now we can use this constant in our code. Next is declaration text section and entry point of program. Program will start to execute from 7 line. Now starts the most interesting part. We already know what is it mov instruction, it gets 2 operands and put value of second to first. But what is it these rax, rdi and etc… As we can read in the wikipedia:</p><pre><code>中央处理器（CPU）是计算机内部的硬件，它通过执行系统的基本算术、逻辑和输入/输出操作来执行计算机程序的指令。</code></pre><pre><code>A central processing unit (CPU) is the hardware within a computer that carries out the instructions of a computer program by performing the basic arithmetical, logical, and input/output operations of the system.</code></pre><p>好的，CPU执行一些操作，算术等… 但是它从哪里可以得到这些操作的数据呢？第一个答案就是内存。然而，读取数据并将数据存储到内存中会减慢处理器的速度，因为它涉及通过控制总线发送数据请求的复杂过程。因此，CPU有自己的内部内存存储位置，称为寄存器：</p><p>Ok, CPU performs some operations, arithmetical and etc… But where can it get data for this operations? The first answer in memory. However, reading data from and storing data into memory slows down the processor, as it involves complicated processes of sending the data request across the control bus. Thus CPU has own internal memory storage locations called registers:</p><p>所以当我们写mov rax，1时，它的意思是把1放到rax寄存器中。现在我们知道什么是rax，rdi，rbx等等…但需要知道何时使用rax，何时rsi等等…</p><p>So when we write mov rax, 1, it means to put 1 to the rax register. Now we know what is it rax, rdi, rbx and etc… But need to know when to use rax but when rsi and etc…</p><ul><li>rax - 临时寄存器；调用syscal时，rax必须包含syscall编号</li><li>rdx - 用于将第三个参数传递给函数</li><li>rdi - 用于将第一个参数传递给函数</li><li>rsi - 用于向函数传递第二个参数的指针</li><li>rax - temporary register; when we call a syscal, rax must contain syscall number</li><li>rdx - used to pass 3rd argument to functions</li><li>rdi - used to pass 1st argument to functions</li><li>rsi - pointer used to pass 2nd argument to functions</li></ul><p>换句话说，我们只是调用sys_write sys call。查看sys_write：</p><p>In another words we just make a call of sys_write syscall. Take a look on sys_write:</p><pre class=" language-c"><code class="language-c">size_t <span class="token function">sys_write</span><span class="token punctuation">(</span><span class="token keyword">unsigned</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> buf<span class="token punctuation">,</span> size_t count<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>他有三个参数:</p><p>It has 3 arguments:</p><ul><li><p>fd - 文件描述符。对应标准输入、标准输出和标准错误，可以是0、1和2</p></li><li><p>buf - 指向字符数组，该数组可用于获取fd指向的文件内容。</p></li><li><p>count - 指定要从文件写入字符数组的字节数</p></li><li><p>fd - file descriptor. Can be 0, 1 and 2 for standard input, standard output and standard error</p></li><li><p>buf - points to a character array, which can be used to store content obtained from the file pointed to by fd.</p></li><li><p>count - specifies the number of bytes to be written from the file into the character array</p></li></ul><p>所以我们知道sys_write syscall有三个参数，在syscall表中是第一个。让我们再来看看我们的hello world实现。我们将1放入rax寄存器，这意味着我们将使用sys_write系统调用。在下一行中，我们将1放入rdi寄存器，它将是sys_write的第一个参数，1-标准输出。然后我们将指向msg的指针存储在rsi寄存器中，它将是sys_write的第二个buf参数。然后我们将最后一个（第三个）参数（字符串长度）传递给rdx，它将是sys_write的第三个参数。现在我们有了sys_write的所有参数，可以用sys call函数在11行调用它。好的，我们打印了“Hello World”字符串，现在需要正确地退出程序。我们传递60到RAX寄存器，60是一个信号退出syscall。并将0传递给rdi寄存器，它是错误代码，所以0表示我们的程序成功退出。这就是“你好世界”的全部内容。很简单：）现在让我们构建我们的程序。例如，hello.asm文件中有此代码。然后我们需要执行以下命令：</p><p>So we know that sys_write syscall takes three arguments and has number one in syscall table. Let’s look again to our hello world implementation. We put 1 to rax register, it means that we will use sys_write system call. In next line we put 1 to rdi register, it will be first argument of sys_write, 1 - standard output. Then we store pointer to msg at rsi register, it will be second buf argument for sys_write. And then we pass the last (third) parameter (length of string) to rdx, it will be third argument of sys_write. Now we have all arguments of the sys_write and we can call it with syscall function at 11 line. Ok, we printed “Hello world” string, now need to do correctly exit from program. We pass 60 to rax register, 60 is a number of exit syscall. And pass also 0 to rdi register, it will be error code, so with 0 our program must exit successfully. That’s all for “Hello world”. Quite simple :) Now let’s build our program. For example we have this code in hello.asm file. Then we need to execute following commands:</p><pre class=" language-bash"><code class="language-bash">$ nasm -f elf64 -o hello.o hello.asm$ ld -o hello hello.o</code></pre><p>在它之后，我们将拥有可执行的hello文件，我们可以使用./hello运行它，并将在终端中看到hello world字符串。</p><p>After it we will have executable hello file which we can run with ./hello and will see Hello world string in the terminal.</p>]]></content>
      
      
      
        <tags>
            
            <tag> x86 </tag>
            
            <tag> x64 </tag>
            
            <tag> 汇编 </tag>
            
            <tag> assembly </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无需权限获取应用程序列表</title>
      <link href="/2019/12/29/get-app-list/"/>
      <url>/2019/12/29/get-app-list/</url>
      
        <content type="html"><![CDATA[<h3 id="无需权限获取应用程序列表"><a href="#无需权限获取应用程序列表" class="headerlink" title="无需权限获取应用程序列表"></a>无需权限获取应用程序列表</h3><p>最近在研究反编译的时候发现了系统的一种漏洞方式获取应用程序信息,这个可以无需任何权限,用户无任何感知的获取全部应用程序列表,这对于一些特别需要知道用户手机内是否安装了某些特定应用的的人来说真的是太好了.</p><p>经过我自己的实验,华为三星等手机没有任何问题.简单的跟大家分享一下我的研究成果.</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">getPackageList</span><span class="token punctuation">(</span>Context ctx<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"TAG"</span><span class="token punctuation">,</span> <span class="token string">"无需权限获取应用列表"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        PackageManager v9 <span class="token operator">=</span> ctx<span class="token punctuation">.</span><span class="token function">getPackageManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String<span class="token punctuation">[</span><span class="token punctuation">]</span> v2 <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">int</span> uid <span class="token operator">=</span> <span class="token number">1000</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>uid <span class="token operator">&lt;=</span> <span class="token number">19999</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            v2 <span class="token operator">=</span> v9<span class="token punctuation">.</span><span class="token function">getPackagesForUid</span><span class="token punctuation">(</span>uid<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>v2 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> v2<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>String item <span class="token operator">:</span> v2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">try</span> <span class="token punctuation">{</span>                        <span class="token keyword">final</span> PackageInfo v6 <span class="token operator">=</span> v9<span class="token punctuation">.</span><span class="token function">getPackageInfo</span><span class="token punctuation">(</span>item<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span>v6 <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token keyword">break</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        CharSequence v7 <span class="token operator">=</span> v9<span class="token punctuation">.</span><span class="token function">getApplicationLabel</span><span class="token punctuation">(</span>v9<span class="token punctuation">.</span><span class="token function">getApplicationInfo</span><span class="token punctuation">(</span>v6<span class="token punctuation">.</span>packageName<span class="token punctuation">,</span> PackageManager<span class="token punctuation">.</span>GET_META_DATA<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span><span class="token string">"TAG"</span><span class="token punctuation">,</span> <span class="token string">"应用名称 = "</span> <span class="token operator">+</span> v7<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" ("</span> <span class="token operator">+</span> v6<span class="token punctuation">.</span>packageName <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">PackageManager<span class="token punctuation">.</span>NameNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            uid<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 应用列表 </tag>
            
            <tag> 权限 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DEX文件结构与解析</title>
      <link href="/2019/12/28/dex-wen-jian-jie-gou-yu-jie-xi/"/>
      <url>/2019/12/28/dex-wen-jian-jie-gou-yu-jie-xi/</url>
      
        <content type="html"><![CDATA[<h1 id="DEX文件结构与解析"><a href="#DEX文件结构与解析" class="headerlink" title="DEX文件结构与解析"></a>DEX文件结构与解析</h1><p>Dex是Dalvik虚拟机的执行文件，对于每一个开发者来说，他的结构对于开发这至关重要，也是我们优化的一个方面，虽然很多工作是Android Stuido和其对应的工具进行的，但是我们需要知道他的基础结构和工作原理.由于近期的工作原因,特意研究了一下dex的完整结构,并且用kotlin写了完整的结构解析代码,除了dex具体的代码解析以外的其他结构解析都已经完成.特此总结一下学到的东西,希望与大家一起进步.</p><h3 id="前期准备工作"><a href="#前期准备工作" class="headerlink" title="前期准备工作"></a>前期准备工作</h3><p>1.我们在探索Dex文件结构时候需要使用一些工具，我个人推荐使用010Editor，加上Dex模板，这样更好的方便我们分析Dex的结构</p><p>2.分析的Dex文件是我自己用Timber（一个开元音乐播放器）代码编译的。如果需要可以自己找个合适的分析对象</p><h3 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h3><p>将dex从apk中解压出来，拖入010editor中，此时因为dex文件比较大，010Editor会提示是否继续进行分析</p><p><img src="https://zhanweisun.github.io/image/openDex.png?raw=true" alt=""></p><p>分析完成以后会在下面产生一个结构列表，我们分析就靠这个结构列表和对应的数据了。</p><p><strong><img src="https://zhanweisun.github.io/image/dexStruct.png?raw=true" alt="dexStruct"></strong></p><h4 id="Dex头部"><a href="#Dex头部" class="headerlink" title="Dex头部"></a>Dex头部</h4><p>首先我们用鼠标选中结构的第一行，可以看到上面文本去默认会被高亮，这第一段里面的就是Dex文件的头部</p><h5 id="MagicNumber"><a href="#MagicNumber" class="headerlink" title="MagicNumber"></a>MagicNumber</h5><p>Dex文件头的前8个byte是用来识别dex文件的MagicNumber，内容是Dex.035,并以00结尾，十六进制值为 <strong>64 65 78 0A 30 33 35 00</strong></p><h5 id="CheckSum"><a href="#CheckSum" class="headerlink" title="CheckSum"></a>CheckSum</h5><p>Dex文件的adler32校验和，长度4个字节，校验文件除去 maigc、checksum 外余下的所有文件区域</p><h5 id="SHA1-Signature"><a href="#SHA1-Signature" class="headerlink" title="SHA1 Signature"></a>SHA1 Signature</h5><p>接下来的20个字节是ＳＨＡ１的签名</p><h5 id="File-Size-文件长度"><a href="#File-Size-文件长度" class="headerlink" title="File Size 文件长度"></a>File Size 文件长度</h5><p>文件长度４个字节，所以单个Ｄｅｘ文件大小不可能超过４ＧＢ，但是因为可以拆分分多个Ｄｅｘ，所以使用４字节也是足够了</p><h5 id="Header-Size"><a href="#Header-Size" class="headerlink" title="Header Size"></a>Header Size</h5><p>长度４字节，标记整个头部的长度，这里的值是0x00 00 00 70,十进制是112，如果我们选中010Editor下面的结构框的第一个名字叫　struct header_item dex_header 的item ,我们就能发现，上面选中的结构大小刚好是0Ｈ到6FＨ,共计７０Ｈ个数据,这个值一般是固定的</p><h5 id="EndianTag"><a href="#EndianTag" class="headerlink" title="EndianTag"></a>EndianTag</h5><p>长度４个字节，用来标记大小端，默认值是0x12 34 56 78,指定ｃｐｕ的运行环境是大端还是小端，默认的ｉｎｔｅｌ使用的是小端，所以在010Editor上面看到的是78 56 34 12，这个请注意！！！</p><h5 id="LinkSize-amp-LinkOff-字段"><a href="#LinkSize-amp-LinkOff-字段" class="headerlink" title="LinkSize &amp; LinkOff 字段"></a>LinkSize &amp; LinkOff 字段</h5><p>这两个字段指定连接段的大小和对应的文件偏移地址，通常情况都为0，linksize为0表示静态链接</p><h5 id="mapOff"><a href="#mapOff" class="headerlink" title="mapOff"></a>mapOff</h5><p>指定了DexMapList的结构在Dex文件中的位置偏移，这个DexMapList结构是其他结构的一个数据大纲，里面记录了这些结构的一些信息。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> DexMapList <span class="token punctuation">{</span>    u4 size<span class="token punctuation">;</span>               <span class="token comment" spellcheck="true">/* DexMapItem的个数 */</span>    DexMapItem list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* DexMapItem的结构 */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> DexMapItem <span class="token punctuation">{</span>       u2 type<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">/* kDexType开头的类型 */</span>    u2 unused<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 未使用，用于字节对齐 */</span>    u4 size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* type指定类型的个数，它们在dex文件中连续存放 */</span>    u4 offset<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 指定类型数据的文件偏移 */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/* type字段为一个枚举常量，通过类型名称很容易判断它的具体类型。 */</span><span class="token comment" spellcheck="true">/* map item type codes */</span><span class="token keyword">enum</span> <span class="token punctuation">{</span>    kDexTypeHeaderItem               <span class="token operator">=</span> <span class="token number">0x0000</span><span class="token punctuation">,</span>    kDexTypeStringIdItem             <span class="token operator">=</span> <span class="token number">0x0001</span><span class="token punctuation">,</span>    kDexTypeTypeIdItem               <span class="token operator">=</span> <span class="token number">0x0002</span><span class="token punctuation">,</span>    kDexTypeProtoIdItem              <span class="token operator">=</span> <span class="token number">0x0003</span><span class="token punctuation">,</span>    kDexTypeFieldIdItem              <span class="token operator">=</span> <span class="token number">0x0004</span><span class="token punctuation">,</span>    kDexTypeMethodIdItem             <span class="token operator">=</span> <span class="token number">0x0005</span><span class="token punctuation">,</span>    kDexTypeClassDefItem             <span class="token operator">=</span> <span class="token number">0x0006</span><span class="token punctuation">,</span>    kDexTypeMapList                  <span class="token operator">=</span> <span class="token number">0x1000</span><span class="token punctuation">,</span>    kDexTypeTypeList                 <span class="token operator">=</span> <span class="token number">0x1001</span><span class="token punctuation">,</span>    kDexTypeAnnotationSetRefList     <span class="token operator">=</span> <span class="token number">0x1002</span><span class="token punctuation">,</span>    kDexTypeAnnotationSetItem        <span class="token operator">=</span> <span class="token number">0x1003</span><span class="token punctuation">,</span>    kDexTypeClassDataItem            <span class="token operator">=</span> <span class="token number">0x2000</span><span class="token punctuation">,</span>    kDexTypeCodeItem                 <span class="token operator">=</span> <span class="token number">0x2001</span><span class="token punctuation">,</span>    kDexTypeStringDataItem           <span class="token operator">=</span> <span class="token number">0x2002</span><span class="token punctuation">,</span>    kDexTypeDebugInfoItem            <span class="token operator">=</span> <span class="token number">0x2003</span><span class="token punctuation">,</span>    kDexTypeAnnotationItem           <span class="token operator">=</span> <span class="token number">0x2004</span><span class="token punctuation">,</span>    kDexTypeEncodedArrayItem         <span class="token operator">=</span> <span class="token number">0x2005</span><span class="token punctuation">,</span>    kDexTypeAnnotationsDirectoryItem <span class="token operator">=</span> <span class="token number">0x2006</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><img src="https://zhanweisun.github.io/image/DexMapListStruct.jpg?raw=true" alt="DexMapListStruct"></p><p>这个dex_map_list 结构保存在DEX文件的最末尾处，并且第一个字节就是保存的结构数量，也就是map_item的数量</p><p>map_item结构如下图所示,单一结构长度位12个字节，其中前两个字节是描述对应的段类型，紧跟着的2个字节是对齐字节，无意义。接下来的4个字节是对应的段大小，最后的4个字节是对应的段偏移，以上就是关于mapoff对应的内容的解释</p><p><img src="https://zhanweisun.github.io/image/map_item.jpg?raw=true" alt=""></p><h5 id="stringIdsSize-amp-amp-stringIdsOff字段"><a href="#stringIdsSize-amp-amp-stringIdsOff字段" class="headerlink" title="stringIdsSize &amp;&amp; stringIdsOff字段"></a>stringIdsSize &amp;&amp; stringIdsOff字段</h5><p>这两个字段是用来标记所有字符串的，stringIdsSize标记字符串的数量，stringIdsOff标记字符串偏移的首地址，知道这两个数据以后，我们就可以进行字符串的解析了.</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> DexStringId <span class="token punctuation">{</span>    u4 stringDataOff<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 字符串数据偏移 */</span><span class="token punctuation">}</span></code></pre><p>我们先看一下stringIdsOff 这个值，截图如下</p><p><img src="https://zhanweisun.github.io/image/string_ids_off.jpg?raw=true" alt="string_ids_off"></p><p>我们可以看到这个数值位 70 00 00 00,这个是不是很熟悉？我们去看一下，dex的header值是多少？ 是70H，因为我们这个数值存放的问题，实际这个偏移值就是70H。</p><p>也就是说，我们的Dex头部的后面紧跟着就是字符串的相关数据了。我们接着说字符串数据的解析</p><p>我们把结构选择到010Editor的第二个结构体，也就是struct string_id_list dex_string_ids这里，选中这个结构体我们可以看到这个结构的全部内容。如下</p><p><img src="https://zhanweisun.github.io/image/string_id_list.jpg?raw=true" alt="string_id_list"></p><p>这里的展开的每一个item就是一个字符串的索引，这里强调一下是索引。不是真正的字符串。这个值对应的是真正的字符串的偏移地址，我们后面需要用到的字符串，会通过这个索引进行查表找到对应的字符串。</p><h5 id="typeIdsSize-amp-typeIdsOff"><a href="#typeIdsSize-amp-typeIdsOff" class="headerlink" title="typeIdsSize &amp; typeIdsOff"></a>typeIdsSize &amp; typeIdsOff</h5><p>类型区的大小和对应的类型名字的偏移索引。</p><p>这个索引的起始地址就是typeIdsOff对应的值，这个值在我的dex文件上面是0x00 02 DD 9C,然后这个起始地址开始有6393个数据，我们现在跳转到对应的地址看一下。</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> DexTypeId <span class="token punctuation">{</span>    u4 descriptorIdx<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 指向 DexStringId列表的索引 */</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><img src="https://zhanweisun.github.io/image/type_ids_offset.jpg?raw=true" alt="type_ids_offset"></p><p>想要精准的跳到对应的地址，我们可以直接选择结构列表里面的struct type_id_list dex_type_ids,010Editor会自动帮我们定位到对应的位置,这个时候我们再来看一下这个结构的全部数据，已经被选中了.如果我们展开这个结构，下面是每一个item的索引和item的内部结构，我们可以数一下索引的值，我这里的是从0-6392,一共是6393个结构。所以这个刚好跟我们头部的数据是对应的。</p><p>接下来我们看一些type_id_item的值，大家可以在010Editor里面进行查看。里面能够看到很多的类型,例如byte，float，还有这个dex中的类对应的类型</p><p><img src="https://zhanweisun.github.io/image/type_id.jpg?raw=true" alt="type_id"></p><h5 id="protoIdsSize-amp-protoIdsOff"><a href="#protoIdsSize-amp-protoIdsOff" class="headerlink" title="protoIdsSize &amp; protoIdsOff"></a>protoIdsSize &amp; protoIdsOff</h5><p>protoIdsOff指向了函数原型的偏移地址，主要的标记内容  方法声明=返回类型 + 参数列表，protoIds标记对应的数量.从对应的value里面，我们就能看到函数返回值，参数类型等函数原型的标记</p><pre class=" language-c"><code class="language-c">zstruct DexProtoId <span class="token punctuation">{</span>    u4 shortyIdx<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 指向DexStringId列表的索引 */</span>    u4 returnTypeIdx<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 指向DexTypeId列表的索引 */</span>    u4 parametersOff<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 指向DexTypeList的偏移 */</span><span class="token punctuation">}</span><span class="token keyword">struct</span> DexTypeList <span class="token punctuation">{</span>    u4 size<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">/* 接下来DexTypeItem的个数 */</span>    DexTypeItem list<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">/* DexTypeItem结构 */</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> DexTypeItem <span class="token punctuation">{</span>    u2 typeIdx<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 指向DexTypeId列表的索引 */</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><img src="https://zhanweisun.github.io/image/proto_ids.jpg?raw=true" alt="proto_ids"></p><h5 id="field-ids-size-amp-field-ids-off"><a href="#field-ids-size-amp-field-ids-off" class="headerlink" title="field_ids_size &amp; field_ids_off"></a>field_ids_size &amp; field_ids_off</h5><p>field_ids_off偏移地址指向的结构数据全部是索引值，指明了字段所在的类、字段的类型以及字段名</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> DexFieldId <span class="token punctuation">{</span>    u2 classIdx<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 类的类型，指向DexTypeId列表的索引 */</span>    u2 typeIdx<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 字段类型，指向DexTypeId列表的索引 */</span>    u4 nameIdx<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/* 字段名，指向DexStringId列表的索引 */</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>具体请看下图,class_idx 这个field所属的类的索引值，type_idx是这个field对应的类型索引值,name_idx是这个字段的名称对应的索引值</p><p><img src="https://zhanweisun.github.io/image/field_id.jpg?raw=true" alt="field_id"></p><h6 id="method-ids-size-amp-method-ids-off"><a href="#method-ids-size-amp-method-ids-off" class="headerlink" title="method_ids_size &amp; method_ids_off"></a>method_ids_size &amp; method_ids_off</h6><p>method_ids_off 指定了函数方法的偏移位置，具体的字段如下代码所示</p><pre class=" language-c"><code class="language-c"><span class="token keyword">struct</span> DexMethodId <span class="token punctuation">{</span>    u2 classIdx<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 类的类型，指向DexTypeId列表的索引 */</span>    u2 protoIdx<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">/* 声明类型，指向DexProtoId列表的索引 */</span>    u4 nameIdx<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">/* 方法名，指向DexStringId列表的索引 */</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>classIdx 指向这个方法所在的类对象的索引，通过索引可以获取到类对象的名称</p><p>protoIdx指向的是这个方法声明的原型字符串的索引</p><p>nameIdx获取这个方法名称的字符串索引</p><p> 有了这三个索引对应的字符串，我们就可以获取到正确的类，方法名，参数和返回值，还是使用我们的010Editor，我们打开method_id_list dex_method_ids这个结构下面的item，我们就可以看到这些数据获取以后，我们能知道的一些东西，具体看下图</p><p><img src="https://zhanweisun.github.io/image/method_idx.jpg?raw=true" alt="method_idx"></p><p>我们可以在结构体的最上面看到整个的方法原型，这个是由下面的三个字段对应的字符串值拼接成的，可以完整的看到方法的声明细节。</p><h5 id="class-defs-size-amp-class-defs-off"><a href="#class-defs-size-amp-class-defs-off" class="headerlink" title="class_defs_size &amp; class_defs_off"></a>class_defs_size &amp; class_defs_off</h5><p>class_defs_off指向的是类定义的偏移地址，这里的类定义结构比较复杂，里面嵌套了很多层，我们先来看一下010Editor的结构</p><p><img src="https://zhanweisun.github.io/image/class_struct_item.jpg?raw=true" alt="class_struct_item"></p><p>在这个结构里面，我们能看到一些基本的信息，比如class_idx索引等等,访问的标志等等,</p><p>class_def_item的结构如下</p><pre class=" language-c"><code class="language-c">uint   <span class="token number">32</span><span class="token operator">-</span>bit <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> little<span class="token operator">-</span>endian<span class="token keyword">struct</span> class_def_item<span class="token punctuation">{</span>    uint class_idx<span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">//描述具体的 class 类型，值是 type_ids 的一个 index 。值必须是一个 class 类型，不能是数组类型或者基本类型。   </span>    uint access_flags<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//描述 class 的访问类型，诸如 public , final , static 等。在 dex-format.html 里 “access_flags Definitions” 有具体的描述 </span>    uint superclass_idx<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//描述 supperclass 的类型，值的形式跟 class_idx 一样 </span>    uint interface_off<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">//值为偏移地址，指向 class 的 interfaces，被指向的数据结构为 type_list 。class 若没有 interfaces 值为 0</span>    uint source_file_idx<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//表示源代码文件的信息，值是 string_ids 的一个 index。若此项信息缺失，此项值赋值为 NO_INDEX=0xffff ffff</span>    uint annotations_off<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//值是一个偏移地址，指向的内容是该 class 的注释，位置在 data 区，格式为 annotations_direcotry_item。若没有此项内容，值为 0 </span>    uint class_data_off<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//值是一个偏移地址，指向的内容是该 class 的使用到的数据，位置在 data 区，格式为 class_data_item。若没有此项内容值为 0。该结构里有很多内容，详细描述该 class 的 field、method, method 里的执行代码等信息，后面会介绍 class_data_item</span>    uint static_value_off<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//值是一个偏移地址 ，指向 data 区里的一个列表 (list)，格式为 encoded_array_item。若没有此项内容值为 0</span><span class="token punctuation">}</span></code></pre><p>如果仔细对比你就会发现，010Editor会将annotations_off指向的数据放在他的后面，class_data_off,static_values_off也是一样的处理方式，其实这些数据都在dex结构的其他地方，但是010Editor为了让你查看方便，把他们都放在了一起，实际的class_def_item结构都是指向和偏移，真正的解析都在对应的地址位置而不在这个类定义的结构里面</p><h6 id="class-def-item-中的-annotations-off指向的内容"><a href="#class-def-item-中的-annotations-off指向的内容" class="headerlink" title="class_def_item 中的 annotations_off指向的内容"></a>class_def_item 中的 annotations_off指向的内容</h6><p>annotations指向的是annotation 相关的数据描述，这个描述的结构具体如下</p><pre class=" language-c"><code class="language-c">uint   <span class="token number">32</span><span class="token operator">-</span>bit <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> little<span class="token operator">-</span>endian<span class="token keyword">struct</span> annotation_directory_item<span class="token punctuation">{</span>    uint class_annotations_off<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">//从文件开头到直接在该类上所做的注释的偏移量；如果该类没有任何直接注释，则该值为 0。该偏移量（如果为非零值）应该是到 data 区段中某个位置的偏移量。数据格式由下文的“annotation_set_item”指定。</span>    uint fields_size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//此项所注释的字段数量</span>    uint annotated_methods_size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//此项所注释的方法数量</span>    uint annotated_parameters_size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//此项所注释的方法参数列表的数量</span>    field_annotation field_annotations<span class="token punctuation">[</span>fields_size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（可选）    所关联字段的注释列表。该列表中的元素必须按 field_idx 以升序进行排序。</span>    method_annotation method_annotations<span class="token punctuation">[</span>annotated_methods_size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（可选）    所关联方法的注释列表。该列表中的元素必须按 method_idx 以升序进行排序。</span>    parameter_annotation parameter_annotations<span class="token punctuation">[</span>annotated_parameters_size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//（可选）所关联方法参数的注释列表。该列表中的元素必须按 method_idx 以升序进行排序。</span><span class="token punctuation">}</span><span class="token keyword">struct</span> field_annotation<span class="token punctuation">{</span>    uint field_idx<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//字段（带注释）标识的 field_ids 列表中的索引</span>    uint annotations_off<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//字段（带注释）标识的 field_ids 列表中的索引</span><span class="token punctuation">}</span><span class="token keyword">struct</span> method_annotation<span class="token punctuation">{</span>    uint method_idx<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//方法（带注释）标识的 method_ids 列表中的索引</span>    uint annotations_off<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//从文件开头到该方法注释列表的偏移量。偏移量应该是到 data 区段中某个位置的偏移量。数据格式由下文的“annotation_set_item”指定。</span><span class="token punctuation">}</span><span class="token keyword">struct</span> parameter_annotation<span class="token punctuation">{</span>    uint method_idx<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//方法（其参数带注释）标识的 method_ids 列表中的索引</span>    uint annotations_off<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//从文件开头到该方法参数的注释列表的偏移量。偏移量应该是到 data 区段中某个位置的偏移量。数据格式由下文的“annotation_set_ref_list”指定。</span><span class="token punctuation">}</span><span class="token keyword">struct</span> annotation_set_ref_list<span class="token punctuation">{</span>    unit size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//列表的大小（以条目数表示）</span>    annotation_set_ref_item<span class="token punctuation">[</span>size<span class="token punctuation">]</span> list<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//列表的元素</span><span class="token punctuation">}</span><span class="token keyword">struct</span> annotation_set_ref_item<span class="token punctuation">{</span>    unit annotations_off<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//从文件开头到所引用注释集的偏移量；如果此元素没有任何注释，则该值为 0。该偏移量（如果为非零值）应该是到 data 区段中某个位置的偏移量。数据格式由下文的“annotation_set_item”指定。</span><span class="token punctuation">}</span><span class="token keyword">struct</span> annotation_set_item<span class="token punctuation">{</span>    unit size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//该集合的大小（以条目数表示）</span>    annotation_off_item<span class="token punctuation">[</span>size<span class="token punctuation">]</span> entries<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//该集合的元素。这些元素必须按 type_idx 以升序进行排序。</span><span class="token punctuation">}</span><span class="token keyword">struct</span> annotation_off_item<span class="token punctuation">{</span>    unit annotation_off<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//从文件开头到注释的偏移量。该偏移量应该是到 data 区段中某个位置的偏移量，且该位置的数据格式由下文的“annotation_item”指定。</span><span class="token punctuation">}</span><span class="token keyword">struct</span> annotation_item<span class="token punctuation">{</span>    ubyte visibility<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//此注释的预期可见性（见下文）</span>   encoded_annotation annotation<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//已编码的注释内容，采用上文的“encoded_value 编码”下的“encoded_annotation 格式”所述的格式。</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//可见值</span><span class="token comment" spellcheck="true">// VISIBILITY_BUILD            0x00    预计仅在构建时（例如，在编译其他代码期间）可见</span><span class="token comment" spellcheck="true">//VISIBILITY_RUNTIME    0x01    预计在运行时可见</span><span class="token comment" spellcheck="true">//VISIBILITY_SYSTEM          0x02      预计在运行时可见，但仅对基本系统（而不是常规用户代码）可见</span><span class="token keyword">struct</span> encoded_array_item<span class="token punctuation">{</span>    encoded_array value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用于表示编码数组值的字节，采用上文的“encoded_value 编码”下的“encoded_array 格式”指定的格式。</span><span class="token punctuation">}</span><span class="token keyword">struct</span> hiddenapi_class_data_item<span class="token punctuation">{</span>    unit size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//该区段的总大小</span>    unit<span class="token punctuation">[</span><span class="token punctuation">]</span> offsets<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//由 class_idx 编入索引的偏移量数组。索引 class_idx 中的零数组意味着此 class_idx 没有任何数据，或者所有隐藏 API 标记均为零。否则，数组条目为非零值，并且包含从该区段开头到此 class_idx 的隐藏 API 标记数组的偏移量。</span>    bleb128<span class="token punctuation">[</span><span class="token punctuation">]</span> flags<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//每个类的隐藏 API 标记的级联数组。可能的标记值如下表所述。标记按照字段的相同编码顺序进行编码，且方法在类数据中编码。</span><span class="token punctuation">}</span>限制标记类型：名称                      值            说明whitelist                <span class="token number">0</span>            此列表中的接口已在 Android 框架软件包索引中正式记录，它们是受支持的接口，您可以自由使用。greylist                <span class="token number">1</span>    包含可以使用的非 SDK 接口的列表（无论应用的目标 API 级别是什么）。blacklist                <span class="token number">2</span>    包含不能使用的非 SDK 接口的列表（无论应用的目标 API 级别是什么）。访问其中任何一个接口都会导致运行时错误。greylist‑max‑o    <span class="token number">3</span>    包含可用于 Android <span class="token number">8</span><span class="token punctuation">.</span>x 及下文的非 SDK 接口列表（除非这些接口受到限制）。greylist‑max‑p    <span class="token number">4</span>    包含可用于 Android <span class="token number">9</span><span class="token punctuation">.</span>x 的非 SDK 接口列表（除非这些接口受到限制）。greylist‑max‑q    <span class="token number">5</span>    包含可用于 Android <span class="token number">10</span><span class="token punctuation">.</span>x 的非 SDK 接口列表（除非这些接口受到限制）。</code></pre><p>如果需要可以参考google的官方文档(需要翻墙)</p><p><a href="https://source.android.com/devices/tech/dalvik/dex-format.html" target="_blank" rel="noopener">https://source.android.com/devices/tech/dalvik/dex-format.html</a></p><h6 id="class-def-item中的class-data-off"><a href="#class-def-item中的class-data-off" class="headerlink" title="class_def_item中的class_data_off"></a>class_def_item中的class_data_off</h6><p>指向 data 区里的 class_data_item 结构，class_data_item 里存放着本 class 使用到的各种数据，下面是 class_data_item 的结构 </p><pre class=" language-c"><code class="language-c">uleb128 <span class="token keyword">unsigned</span> little<span class="token operator">-</span>endian base <span class="token number">128</span> <span class="token keyword">struct</span> class_data_item<span class="token punctuation">{</span>    uleb128 static_fields_size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//静态成员变量的个数</span>    uleb128 instance_fields_size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//实例成员变量个数</span>    uleb128 direct_methods_size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//直接函数个数</span>    uleb128 virtual_methods_size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 虚函数个数</span>    encoded_field  static_fields<span class="token punctuation">[</span>static_fields_size<span class="token punctuation">]</span><span class="token punctuation">;</span>    encoded_field  instance_fields<span class="token punctuation">[</span>instance_fields_size<span class="token punctuation">]</span><span class="token punctuation">;</span>    encoded_method direct_methods<span class="token punctuation">[</span>direct_methods_size<span class="token punctuation">]</span><span class="token punctuation">;</span>    encoded_method virtual_methods<span class="token punctuation">[</span>virtual_methods_size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">struct</span> encoded_field<span class="token punctuation">{</span>    uleb128 filed_idx_diff<span class="token punctuation">;</span>     uleb128 access_flags<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token keyword">struct</span> encoded_method<span class="token punctuation">{</span>    uleb128 method_idx_diff<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//前缀 methd_idx 表示它的值是 method_ids 的一个 index ，后缀 _diff 表示它是于另 外一个 method_idx 的一个差值 ，就是相对于 encodeed_method [] 数组里上一个元素的 method_idx 的差值 。 其实 encoded_filed - > field_idx_diff 表示的也是相同的意思 ，只是编译出来的 Hello.dex 文件里没有使用到 class filed 所以没有仔细讲 ，详细的参考 https://source.android.com/devices/tech/dalvik/dex-format 官网文档。</span>    uleb128 access_flags<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//访问权限，比如 public、private、static、final 等</span>    uleb128 code_off<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//一个指向 data 区的偏移地址，目标是本 method 的代码实现。被指向的结构是code_item，有近 10 项元素</span><span class="token punctuation">}</span><span class="token keyword">struct</span> code_item <span class="token punctuation">{</span>    ushort                         registers_size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//本段代码使用到的寄存器数目</span>    ushort                         ins_size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//method 传入参数的数目</span>    ushort                         outs_size<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//本段代码调用其它 method 时需要的参数个数</span>    ushort                         tries_size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//try_item 结构的个数</span>    uint                         debug_info_off<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//偏移地址，指向本段代码的 debug 信息存放位置，是一个 debug_info_item 结构</span>    uint                         insns_size<span class="token punctuation">;</span>    ushort                         insns <span class="token punctuation">[</span>insns_size<span class="token punctuation">]</span><span class="token punctuation">;</span>     ushort                         paddding<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// optional</span>    try_item                     tries <span class="token punctuation">[</span>tyies_size<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// optional</span>    encoded_catch_handler_list  handlers<span class="token punctuation">;</span>             <span class="token comment" spellcheck="true">// optional</span><span class="token punctuation">}</span><span class="token keyword">struct</span> debug_info_off<span class="token punctuation">{</span>    uleb128 line_start<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//状态机的 line 寄存器的初始值。不表示实际的位置条目</span>    uleb128 parameters_size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//已编码的参数名称的数量。每个方法参数都应该有一个名称，但不包括实例方法的 this（如果有）</span>    uleb128p1<span class="token punctuation">[</span>parameters_size<span class="token punctuation">]</span> paramer_names<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//方法参数名称的字符串索引。NO_INDEX 的编码值表示该关联参数没有可用的名称。该类型描述符和签名隐含在方法描述符和签名中</span><span class="token punctuation">}</span></code></pre><h6 id="class-def-item中的static-value-off"><a href="#class-def-item中的static-value-off" class="headerlink" title="class_def_item中的static_value_off"></a>class_def_item中的static_value_off</h6><pre class=" language-c"><code class="language-c">uleb128  <span class="token keyword">unsigned</span> LEB128<span class="token punctuation">,</span> valriable length<span class="token keyword">struct</span> encoded_array_item<span class="token punctuation">{</span>    encoded_array value<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//表示encoded_value 个数</span><span class="token punctuation">}</span><span class="token keyword">struct</span> encoded_array<span class="token punctuation">{</span>        uleb128 size<span class="token punctuation">;</span>    encoded_value values<span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h5 id="map-list"><a href="#map-list" class="headerlink" title="map_list"></a>map_list</h5><p>我们在前面已经提到过这个map_list,他里面的内容是保存header中对应的描述,里面描述的更加全面，具体的结构如下</p><p>map_list 里先用一个 uint 描述后面有 size 个 map_item，后续就是对应的 size 个 map_item 描述。 map_item 结构有 4 个元素: type 表示该 map_item 的类型，Dalvik Executable Format 里 Type Code 的定义; size 表示再细分此 item，该类型的个数;offset 是第一个元素的针对文件初始位置的偏移量; unuse 是用对齐字节的，无实际用处。</p><pre class=" language-c"><code class="language-c">ushort <span class="token number">16</span><span class="token operator">-</span>bit <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> little<span class="token operator">-</span>endianuint   <span class="token number">32</span><span class="token operator">-</span>bit <span class="token keyword">unsigned</span> <span class="token keyword">int</span><span class="token punctuation">,</span> little<span class="token operator">-</span>endian<span class="token keyword">struct</span> map_list <span class="token punctuation">{</span>    uint     size<span class="token punctuation">;</span>    map_item list <span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token keyword">struct</span> map_item <span class="token punctuation">{</span>    ushort type<span class="token punctuation">;</span>     ushort unuse<span class="token punctuation">;</span>     uint   size<span class="token punctuation">;</span>     uint   offset<span class="token punctuation">;</span><span class="token punctuation">}</span> </code></pre><h5 id="leb128编码"><a href="#leb128编码" class="headerlink" title="leb128编码"></a>leb128编码</h5><p>Dalvik使用readUnsignedLeb128函数来尝试读取一个leb128编码的数值（代码位于dalvik\libdex\Leb128.h中）,那么什么是uleb128呢？</p><p>LEB128即”Little-Endian Base 128”，基于128的小端序编码格式，是对任意有符号或者无符号整型数的可变长度的编码。用LEB128编码的正数，会根据数字的大小改变所占字节数。在android的.dex文件中，他只用来编码32bits的整型数。</p><p><img src="https://zhanweisun.github.io/image/uleb128.png?raw=true" alt="img"></p><p>例子</p><pre><code>LEB128编码的0x02b0 ---&gt; 转换后的数字0x0130转换过程：0x02b0 ---&gt; 0000 0010 1011 0000 --&gt;去除最高位--&gt; 000 0010 011 0000 --&gt;按4bits重排 --&gt; 00 0001 0011 0000 --&gt; 0x130</code></pre><pre class=" language-c"><code class="language-c"><span class="token comment" spellcheck="true">/* * Reads an unsigned LEB128 value, updating the given pointer to point * just past the end of the read value. This function tolerates * non-zero high-order bits in the fifth encoded byte. */</span>DEX_INLINE <span class="token keyword">int</span> <span class="token function">readSignedLeb128</span><span class="token punctuation">(</span><span class="token keyword">const</span> u1<span class="token operator">*</span><span class="token operator">*</span> pStream<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> u1<span class="token operator">*</span> ptr <span class="token operator">=</span> <span class="token operator">*</span>pStream<span class="token punctuation">;</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;=</span> <span class="token number">0x7f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        result <span class="token operator">=</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;&lt;</span> <span class="token number">25</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">25</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> cur <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        result <span class="token operator">=</span> <span class="token punctuation">(</span>result <span class="token operator">&amp;</span> <span class="token number">0x7f</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cur <span class="token operator">&amp;</span> <span class="token number">0x7f</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> <span class="token number">0x7f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result <span class="token operator">=</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;&lt;</span> <span class="token number">18</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">18</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            cur <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            result <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>cur <span class="token operator">&amp;</span> <span class="token number">0x7f</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">14</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> <span class="token number">0x7f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                result <span class="token operator">=</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;&lt;</span> <span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">11</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                cur <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                result <span class="token operator">|</span><span class="token operator">=</span> <span class="token punctuation">(</span>cur <span class="token operator">&amp;</span> <span class="token number">0x7f</span><span class="token punctuation">)</span> <span class="token operator">&lt;&lt;</span> <span class="token number">21</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> <span class="token number">0x7f</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    result <span class="token operator">=</span> <span class="token punctuation">(</span>result <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">>></span> <span class="token number">4</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    cur <span class="token operator">=</span> <span class="token operator">*</span><span class="token punctuation">(</span>ptr<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    result <span class="token operator">|</span><span class="token operator">=</span> cur <span class="token operator">&lt;&lt;</span> <span class="token number">28</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token operator">*</span>pStream <span class="token operator">=</span> ptr<span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>对应的Kotlin代码，我自己写的功能，请大家参考</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">decodeUleb128</span><span class="token punctuation">(</span><span class="token keyword">data</span><span class="token operator">:</span> ByteArray<span class="token punctuation">)</span><span class="token operator">:</span> Long <span class="token punctuation">{</span>    <span class="token keyword">var</span> result<span class="token operator">:</span> Long <span class="token operator">=</span> <span class="token number">0L</span>    <span class="token label symbol">parserByte@</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>index <span class="token keyword">in</span> <span class="token keyword">data</span><span class="token punctuation">.</span>indices<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">val</span> cur <span class="token operator">=</span> <span class="token keyword">data</span><span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toUInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">when</span> <span class="token punctuation">(</span>index<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token number">0</span> <span class="token operator">-></span> <span class="token punctuation">{</span>                result <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token function">toLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> 127u<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//就一个byte，直接赋值，跳出循环</span>                    <span class="token keyword">break</span><span class="token label symbol">@parserByte</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//最高位为1,继续保存值到result里面，继续下一次循环</span>            <span class="token punctuation">}</span>            <span class="token number">1</span> <span class="token operator">-></span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//拼接数据,这里对result的值进行and操作，去掉高位数据</span>                <span class="token keyword">val</span> lowVal <span class="token operator">=</span> <span class="token punctuation">(</span>result <span class="token operator">and</span> <span class="token number">0x7f</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">val</span> hiVal <span class="token operator">=</span> <span class="token punctuation">(</span>cur <span class="token operator">and</span> 127u<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">shl</span> <span class="token number">7</span>                result <span class="token operator">=</span> <span class="token punctuation">(</span>lowVal <span class="token operator">or</span> hiVal<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> 127u<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">//如果最高位不是0,没有数据了，直接返回</span>                    <span class="token keyword">break</span><span class="token label symbol">@parserByte</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">//什么都不做，等着下一次循环，继续操作</span>            <span class="token punctuation">}</span>            <span class="token number">2</span> <span class="token operator">-></span> <span class="token punctuation">{</span>                <span class="token keyword">val</span> hiVal <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>cur <span class="token operator">and</span> 127u<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">shl</span> <span class="token number">14</span><span class="token punctuation">)</span>                result <span class="token operator">=</span> result <span class="token operator">or</span> hiVal<span class="token punctuation">.</span><span class="token function">toLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> 127u<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token label symbol">@parserByte</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token number">3</span> <span class="token operator">-></span> <span class="token punctuation">{</span>                <span class="token keyword">val</span> hiVal <span class="token operator">=</span> <span class="token punctuation">(</span>cur <span class="token operator">and</span> 127u<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">shl</span> <span class="token number">21</span>                result <span class="token operator">=</span> result <span class="token operator">or</span> hiVal<span class="token punctuation">.</span><span class="token function">toLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> 127u<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token label symbol">@parserByte</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token number">4</span> <span class="token operator">-></span> <span class="token punctuation">{</span>                <span class="token keyword">val</span> hiVal <span class="token operator">=</span> cur<span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">shl</span> <span class="token number">28</span>                result <span class="token operator">=</span> result <span class="token operator">or</span> hiVal<span class="token punctuation">.</span><span class="token function">toLong</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>cur <span class="token operator">&lt;=</span> 127u<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token label symbol">@parserByte</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Dex </tag>
            
            <tag> 文件结构 </tag>
            
            <tag> 二进制 </tag>
            
            <tag> 解析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android 代码优化与混淆</title>
      <link href="/2019/12/14/android-dai-ma-you-hua-yu-hun-yao/"/>
      <url>/2019/12/14/android-dai-ma-you-hua-yu-hun-yao/</url>
      
        <content type="html"><![CDATA[<h4 id="Android-代码优化与混淆"><a href="#Android-代码优化与混淆" class="headerlink" title="Android 代码优化与混淆"></a>Android 代码优化与混淆</h4><h3 id="1-android代码优化"><a href="#1-android代码优化" class="headerlink" title="1.android代码优化"></a>1.android代码优化</h3><p>andriod gradle 插件3.4.0版本以上，不在使用ProGurad执行编译代码优化工作，转而使用R8编译器一起处理代码</p><pre class=" language-json"><code class="language-json"><span class="token number">1</span><span class="token punctuation">)</span> 压缩代码，检测依赖库，安全的移除未使用的类，字段，方法和属性，使用 minifyEnabled <span class="token boolean">true</span> 启用代码压缩android <span class="token punctuation">{</span>        ...        buildTypes <span class="token punctuation">{</span>            release <span class="token punctuation">{</span>                minifyEnabled <span class="token boolean">true</span>  //启用R8代码压缩                proguardFiles getDefaultProguardFile(                  'proguard-android-optimize.txt'<span class="token punctuation">)</span><span class="token punctuation">,</span>                  // List additional ProGuard rules for the given build type here. By default<span class="token punctuation">,</span>                  // Android Studio creates and includes an empty rules file for you (located                  // at the root directory of each module<span class="token punctuation">)</span>.                  'proguard-rules.pro'            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-json"><code class="language-json"><span class="token number">2</span><span class="token punctuation">)</span> 压缩资源，移除未使用的资源，包括应用的库依赖项中未使用的资源，要启用资源压缩，请在 build.gradle 文件中将 shrinkResources 属性设为 <span class="token boolean">true</span>（在用于代码压缩的 minifyEnabled 旁边）android <span class="token punctuation">{</span>        ...        buildTypes <span class="token punctuation">{</span>            release <span class="token punctuation">{</span>                shrinkResources <span class="token boolean">true</span>                minifyEnabled <span class="token boolean">true</span>                proguardFiles getDefaultProguardFile('proguard-android.txt'<span class="token punctuation">)</span><span class="token punctuation">,</span>                        'proguard-rules.pro'            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-json"><code class="language-json"><span class="token number">3</span><span class="token punctuation">)</span> 混淆，减少类，成员名称长度，从而减小dex文件体积R8 使用 ProGuard 规则文件来修改其默认行为并更好地了解应用的结构，如充当应用代码入口点的类。&lt;module-dir>/proguard-rules.pro默认情况下，此文件不应用任何规则，这里可以应用你自己的规则，progrard规则请看后面的proguard混淆规则Android Gradle 插件在编译时候会生成 proguard-android-optimize.txt（其中包含对大多数 Android 项目都有用的规则），并启用 @Keep* 注解AAR 库：&lt;library-dir>/proguard.txt如果某个 AAR 库是使用它自己的 ProGuard 规则文件发布的，并且您将该 AAR 库添加为编译时依赖项，则 R8 会在编译项目时自动应用其规则。JAR 库：&lt;library-dir>/META-INF/proguard/因为 ProGuard 规则是累加的，所以 AAR 库依赖项包含的某些规则无法移除，并且可能会影响应用其他部分的编译。例<span class="token punctuation">,</span>如果某个库包含停用代码优化的规则，该规则将针对整个项目停用优化。</code></pre><pre class=" language-json"><code class="language-json"><span class="token number">4</span><span class="token punctuation">)</span> 代码优化，检查并重写代码，以进一步减小应用 DEX 文件的大小。如果您的代码从不采用给定 if/else 语句的 else <span class="token punctuation">{</span><span class="token punctuation">}</span> 分支，R8 可能会移除 else <span class="token punctuation">{</span><span class="token punctuation">}</span> 分支的代码。如果您的代码只在一个位置调用某个方法，R8 可能会移除该方法而将其内嵌在这一个调用点。如果 R8 确定某个类只有一个唯一的子类且该类本身未实例化（例如，一个抽象基类仅由一个具体实现类使用），那么 R8 可以将这两个类组合在一起并从应用中移除一个类。R8代码优化举例，如下代码class MyActivity extends Activity <span class="token punctuation">{</span>  @Override void onCreate(Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    super.onCreate(savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>    String name = this.getClass(<span class="token punctuation">)</span>.getSimpleName(<span class="token punctuation">)</span><span class="token punctuation">;</span>//这是一个很普通的getClass方法调用，但是这个会产生反射调用    Log.e(name<span class="token punctuation">,</span> <span class="token string">"Hello!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span>//-----------------------------------------ByteCode--------------------------------------------------<span class="token punctuation">[</span>0003d0<span class="token punctuation">]</span> MyActivity.onCreate<span class="token operator">:</span>(Landroid/os/Bundle<span class="token punctuation">;</span><span class="token punctuation">)</span>V<span class="token number">0000</span><span class="token operator">:</span> invoke-super <span class="token punctuation">{</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">}</span><span class="token punctuation">,</span> Landroid/app/Activity<span class="token punctuation">;</span>.onCreate<span class="token operator">:</span>(Landroid/os/Bundle<span class="token punctuation">;</span><span class="token punctuation">)</span>V<span class="token number">0003</span><span class="token operator">:</span> invoke-virtual <span class="token punctuation">{</span>v1<span class="token punctuation">}</span><span class="token punctuation">,</span> Ljava/lang/Object<span class="token punctuation">;</span>.getClass<span class="token operator">:</span>(<span class="token punctuation">)</span>Ljava/lang/Class<span class="token punctuation">;</span><span class="token number">0006</span><span class="token operator">:</span> move-result-object v2<span class="token number">0007</span><span class="token operator">:</span> invoke-virtual <span class="token punctuation">{</span>v2<span class="token punctuation">}</span><span class="token punctuation">,</span> Ljava/lang/Class<span class="token punctuation">;</span>.getSimpleName<span class="token operator">:</span>(<span class="token punctuation">)</span>Ljava/lang/String<span class="token punctuation">;</span>  //invoke-virtual调用000a<span class="token operator">:</span> move-result-object v2R8会扫描程序，并分析知道MyActivity根本没有被继承，即使你没有给它加final，这个时候R8会使用MyActivity.class来取代this.getClass(<span class="token punctuation">)</span>的调用，最终的代码可能如下所示//-----------------------------------------ByteCode--------------------------------------------------<span class="token number">0000</span><span class="token operator">:</span> invoke-super <span class="token punctuation">{</span>v1<span class="token punctuation">,</span> v2<span class="token punctuation">}</span><span class="token punctuation">,</span> Landroid/app/Activity<span class="token punctuation">;</span>.onCreate<span class="token operator">:</span>(Landroid/os/Bundle<span class="token punctuation">;</span><span class="token punctuation">)</span>V<span class="token number">0003</span><span class="token operator">:</span> const-string v2<span class="token punctuation">,</span> <span class="token string">"MyActivity"</span></code></pre><h5 id="开启更积极的R8优化"><a href="#开启更积极的R8优化" class="headerlink" title="开启更积极的R8优化"></a>开启更积极的R8优化</h5><p>R8 包含一组额外的优化功能，默认情况下未启用这些功能。您可以通过在项目的 gradle.properties 文件中添加以下代码来启用这些额外的优化功能：</p><pre class=" language-json"><code class="language-json">android.enableR8.fullMode=<span class="token boolean">true</span></code></pre><p>由于额外的优化功能使得 R8 的行为与 ProGuard 不同，因此它们可能要求您添加额外的 ProGuard 规则以避免运行时问题。例如，假设您的代码通过 Java Reflection API 引用一个类。默认情况下，R8 假设您打算在运行时检查和操纵该类的对象（即使您的代码实际上并不这样做），因此它会自动保留该类及其静态初始化程序。不过，在使用“完整模式”时，R8 不会做出这种假设，如果 R8 断言您的代码从不在运行时使用该类，它会从应用的最终 DEX 中移除该类。也就是说，如果要保留该类及其静态初始化程序，需要在规则文件中添加相应的保留规则。</p><h5 id="让R8生成移除代码报告"><a href="#让R8生成移除代码报告" class="headerlink" title="让R8生成移除代码报告"></a>让R8生成移除代码报告</h5><p>为了防止优化后出现问题，并帮助开发者发现优化后的问，我们可以查看R8的优化报告，找到具体优化了那些东西，对于要生成报告的模块，请将-printusage <output-dir>/usage.txt 添加到自定义规则文件内。</p><p>当启用R8并编译应用的时候，R8会输出指定路径的报告</p><p>#####　移除代码报告例子如下</p><pre class=" language-java"><code class="language-java">androidx<span class="token punctuation">.</span>drawerlayout<span class="token punctuation">.</span>R$attr    androidx<span class="token punctuation">.</span>vectordrawable<span class="token punctuation">.</span>R    androidx<span class="token punctuation">.</span>appcompat<span class="token punctuation">.</span>app<span class="token punctuation">.</span>AppCompatDelegateImpl        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setSupportActionBar</span><span class="token punctuation">(</span>androidx<span class="token punctuation">.</span>appcompat<span class="token punctuation">.</span>widget<span class="token punctuation">.</span>Toolbar<span class="token punctuation">)</span>        <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasWindowFeature</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setHandleNativeActionModesEnabled</span><span class="token punctuation">(</span><span class="token keyword">boolean</span><span class="token punctuation">)</span>        android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>ViewGroup <span class="token function">getSubDecor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLocalNightMode</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>        <span class="token keyword">final</span> androidx<span class="token punctuation">.</span>appcompat<span class="token punctuation">.</span>app<span class="token punctuation">.</span>AppCompatDelegateImpl$AutoNightModeManager <span class="token function">getAutoNightModeManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">public</span> <span class="token keyword">final</span> androidx<span class="token punctuation">.</span>appcompat<span class="token punctuation">.</span>app<span class="token punctuation">.</span>ActionBarDrawerToggle$Delegate <span class="token function">getDrawerToggleDelegate</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> DEBUG        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String KEY_LOCAL_NIGHT_MODE        <span class="token keyword">static</span> <span class="token keyword">final</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>String EXCEPTION_HANDLER_MESSAGE_SUFFIX    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><h5 id="生成保留规则确定的入口点报告"><a href="#生成保留规则确定的入口点报告" class="headerlink" title="生成保留规则确定的入口点报告"></a>生成保留规则确定的入口点报告</h5><p>如果要查看 R8 根据项目的保留规则确定的入口点的报告，请在自定义规则文件中添加 -printseeds <output-dir>/seeds.txt。当启用 R8 并编译应用时，R8 会输出一个包含您指定的路径和文件名的报告。保留的入口点的报告与以下输出类似：</p><pre class=" language-java"><code class="language-java">com<span class="token punctuation">.</span>example<span class="token punctuation">.</span>myapplication<span class="token punctuation">.</span>MainActivity    androidx<span class="token punctuation">.</span>appcompat<span class="token punctuation">.</span>R$layout<span class="token operator">:</span> <span class="token keyword">int</span> abc_action_menu_item_layout    androidx<span class="token punctuation">.</span>appcompat<span class="token punctuation">.</span>R$attr<span class="token operator">:</span> <span class="token keyword">int</span> activityChooserViewStyle    androidx<span class="token punctuation">.</span>appcompat<span class="token punctuation">.</span>R$styleable<span class="token operator">:</span> <span class="token keyword">int</span> MenuItem_android_id    androidx<span class="token punctuation">.</span>appcompat<span class="token punctuation">.</span>R$styleable<span class="token operator">:</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> CoordinatorLayout_Layout    androidx<span class="token punctuation">.</span>lifecycle<span class="token punctuation">.</span>FullLifecycleObserverAdapter    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><h3 id="2-proguard-混淆原理"><a href="#2-proguard-混淆原理" class="headerlink" title="2.proguard 混淆原理"></a>2.proguard 混淆原理</h3><p>ProGuard能够对Java类中的代码进行压缩（Shrink）,优化（Optimize）,混淆（Obfuscate）,预检（Preveirfy）。 </p><p>压缩（Shrink）:在压缩处理这一步中，用于检测和删除没有使用的类，字段，方法和属性。 </p><p>优化（Optimize）:在优化处理这一步中，对字节码进行优化，并且移除无用指令。 </p><p>混淆（Obfuscate）:在混淆处理这一步中，使用a,b,c等无意义的名称，对类，字段和方法进行重命名。 </p><p>预检（Preveirfy）:在预检这一步中，主要是在Java平台上对处理后的代码进行预检。</p><p><img src="https://zhanweisun.github.io/image/proguard.jpg?raw=true" alt=""></p><h3 id="2-proguard-rules-pro-混淆配置"><a href="#2-proguard-rules-pro-混淆配置" class="headerlink" title="2.proguard-rules.pro 混淆配置"></a>2.proguard-rules.pro 混淆配置</h3><h5 id="keep-选项"><a href="#keep-选项" class="headerlink" title="keep 选项"></a>keep 选项</h5><pre class=" language-properties"><code class="language-properties"><span class="token attr-name">-keep</span> <span class="token attr-value">[,modifier，...] class_specification</span>指定需要保留的类和类成员（作为公共类库，应该保留所有可公开访问的public方法）<span class="token attr-name">-keepclassmembers</span> <span class="token attr-value">[,modifier，...] class_specification</span><span class="token attr-name">指定需要保留的类成员</span><span class="token punctuation">:</span><span class="token attr-value">变量或者方法</span><span class="token attr-name">-keepclasseswithmembers</span> <span class="token attr-value">[,modifier，...] class_specification</span>指定保留的类和类成员，条件是所指定的类成员都存在（既在压缩阶段没有被删除的成员，效果和keep差不多）<span class="token attr-name">-keepnames</span> <span class="token attr-value">class_specification</span><span class="token attr-name">[-keep</span> <span class="token attr-value">allowshrinking class_specification 的简写]</span>指定要保留名称的类和类成员，前提是在压缩阶段未被删除。仅用于模糊处理<span class="token attr-name">-keepclassmembernames</span> <span class="token attr-value">class_specification</span><span class="token attr-name">[-keepclassmembers</span> <span class="token attr-value">allowshrinking class_specification 的简写]</span>指定要保留名称的类成员，前提是在压缩阶段未被删除。仅用于模糊处理<span class="token attr-name">-keepclasseswithmembernames</span> <span class="token attr-value">class_specification</span><span class="token attr-name">[-keepclasseswithmembers</span> <span class="token attr-value">allowshrinking class_specification 的简写]</span>指定要保留名称的类成员，前提是在压缩阶段后所指定的类成员都存在。仅用于模糊处理</code></pre><h5 id="Keep选项概述对比"><a href="#Keep选项概述对比" class="headerlink" title="Keep选项概述对比"></a>Keep选项概述对比</h5><table><thead><tr><th>作用范围</th><th>保持所指定类、成员</th><th>所指定类、成员在压缩阶段没有被删除，才能被保持</th></tr></thead><tbody><tr><td>类和类成员</td><td>-keep</td><td>-keepnames</td></tr><tr><td>仅类成员</td><td>-keepclassmembers</td><td>-keepclassmembernames</td></tr><tr><td>类和类成员(前提是成员都存在)</td><td>-keepclasseswithmembers</td><td>-keepclasseswithmembernames</td></tr></tbody></table><h3 id="Proguard通配符"><a href="#Proguard通配符" class="headerlink" title="Proguard通配符"></a>Proguard通配符</h3><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody><tr><td><field></td><td>匹配类中的所有字段</td></tr><tr><td><method></td><td>匹配类中所有的方法</td></tr><tr><td><init></td><td>匹配类中所有的构造函数</td></tr><tr><td>*</td><td>匹配任意长度字符，不包含包名分隔符(.)</td></tr><tr><td>**</td><td>匹配任意长度字符，包含包名分隔符(.)</td></tr><tr><td>***</td><td>匹配任意参数类型</td></tr></tbody></table><h5 id="keep使用例子"><a href="#keep使用例子" class="headerlink" title="keep使用例子"></a>keep使用例子</h5><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 保留所有的本地native方法不被混淆</span><span class="token attr-name">-keepclasseswithmembernames</span> <span class="token attr-value">class * {</span><span class="token attr-name">    native</span> <span class="token attr-value">&lt;methods>;</span>}<span class="token comment" spellcheck="true"># 保留了继承自Activity、Application这些类的子类</span><span class="token comment" spellcheck="true"># 因为这些子类，都有可能被外部调用</span><span class="token comment" spellcheck="true"># 比如说，第一行就保证了所有Activity的子类不要被混淆</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class * extends android.app.Activity</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class * extends android.app.Application</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class * extends android.app.Service</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class * extends android.content.BroadcastReceiver</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class * extends android.content.ContentProvider</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class * extends android.app.backup.BackupAgentHelper</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class * extends android.preference.Preference</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class * extends android.view.View</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class com.android.vending.licensing.ILicensingService</span><span class="token comment" spellcheck="true"># 保留在Activity中的方法参数是view的方法，</span><span class="token comment" spellcheck="true"># 从而我们在layout里面编写onClick就不会被影响</span><span class="token attr-name">-keepclassmembers</span> <span class="token attr-value">class * extends android.app.Activity {</span><span class="token attr-name">    public</span> <span class="token attr-value">void *(android.view.View);</span>}<span class="token comment" spellcheck="true"># 枚举类不能被混淆</span><span class="token attr-name">-keepclassmembers</span> <span class="token attr-value">enum * {</span><span class="token attr-name">    public</span> <span class="token attr-value">static **[] values();</span><span class="token attr-name">    public</span> <span class="token attr-value">static ** valueOf(java.lang.String);</span>}<span class="token comment" spellcheck="true"># 保留自定义控件（继承自View）不被混淆</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class * extends android.view.View {</span><span class="token attr-name">    ***</span> <span class="token attr-value">get*();</span><span class="token attr-name">    void</span> <span class="token attr-value">set*(***);</span><span class="token attr-name">    public</span> <span class="token attr-value">&lt;init>(android.content.Context);</span><span class="token attr-name">    public</span> <span class="token attr-value">&lt;init>(android.content.Context, android.util.AttributeSet);</span><span class="token attr-name">    public</span> <span class="token attr-value">&lt;init>(android.content.Context, android.util.AttributeSet, int);</span><span class="token comment" spellcheck="true">    #这里需要注意,其实目前最新的View有第四个构造参数,所以混淆的时候一定记得加上,这样防止出现崩溃</span>}<span class="token comment" spellcheck="true"># 保留Parcelable序列化的类不被混淆</span><span class="token attr-name">-keep</span> <span class="token attr-value">class * implements android.os.Parcelable {</span><span class="token attr-name">    public</span> <span class="token attr-value">static final android.os.Parcelable$Creator *;</span>}<span class="token comment" spellcheck="true"># 保留Serializable序列化的类不被混淆</span><span class="token attr-name">-keepclassmembers</span> <span class="token attr-value">class * implements java.io.Serializable {</span><span class="token attr-name">    static</span> <span class="token attr-value">final long serialVersionUID;</span><span class="token attr-name">    private</span> <span class="token attr-value">static final java.io.ObjectStreamField[] serialPersistentFields;</span><span class="token attr-name">    private</span> <span class="token attr-value">void writeObject(java.io.ObjectOutputStream);</span><span class="token attr-name">    private</span> <span class="token attr-value">void readObject(java.io.ObjectInputStream);</span><span class="token attr-name">    java.lang.Object</span> <span class="token attr-value">writeReplace();</span><span class="token attr-name">    java.lang.Object</span> <span class="token attr-value">readResolve();</span>}<span class="token comment" spellcheck="true"># 对于R（资源）下的所有类及其方法，都不能被混淆</span><span class="token attr-name">-keep</span> <span class="token attr-value">class **.R$* {</span>    *;}<span class="token comment" spellcheck="true"># 对于带有回调函数onXXEvent的，不能被混淆</span><span class="token attr-name">-keepclassmembers</span> <span class="token attr-value">class * {</span><span class="token attr-name">    void</span> <span class="token attr-value">*(**On*Event);</span>}<span class="token comment" spellcheck="true"># 保留实体类和成员不被混淆</span><span class="token comment" spellcheck="true"># 对于实体，保留它们的set和get方法，对于boolean型get方法，有人喜欢命名isXXX的方式，所以不要遗漏。</span><span class="token comment" spellcheck="true">#一种好的做法是把所有实体都放在一个包下进行管理，这样只写一次混淆就够了，避免以后在别的包中新增的实体而忘记保留，代码在混淆后因为找不到相应的实体类而崩溃。</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class com.xxxx.entity.** {</span><span class="token attr-name">    public</span> <span class="token attr-value">void set*(***);</span><span class="token attr-name">    public</span> <span class="token attr-value">*** get*();</span><span class="token attr-name">    public</span> <span class="token attr-value">*** is*();</span>}<span class="token comment" spellcheck="true"># 保留内嵌类不被混淆</span><span class="token comment" spellcheck="true"># 内部类经常会被混淆，结果在调用的时候为空就崩溃了，最好的解决方法就是把这个内部类拿出来，单独成为一个类。如果一定要内置，那么这个类就必须在混淆的时候保留，建议少用内部类</span><span class="token attr-name">-keep</span> <span class="token attr-value">class com.example.xxx.MainActivity$* { *; }</span><span class="token comment" spellcheck="true">#针对WebView的处理</span><span class="token comment" spellcheck="true">#如果使用的是腾讯的x5浏览器，请到腾讯x5浏览器官网获得keep的具体内容</span><span class="token attr-name">-keepclassmembers</span> <span class="token attr-value">class * extends android.webkit.webViewClient {</span><span class="token attr-name">    public</span> <span class="token attr-value">void *(android.webkit.WebView, java.lang.String, android.graphics.Bitmap);</span><span class="token attr-name">    public</span> <span class="token attr-value">boolean *(android.webkit.WebView, java.lang.String)</span>}<span class="token attr-name">-keepclassmembers</span> <span class="token attr-value">class * extends android.webkit.we使用annotationbViewClient {</span><span class="token attr-name">    public</span> <span class="token attr-value">void *(android.webkit.webView, java.lang.String)</span>}<span class="token comment" spellcheck="true">#对应的Java层的js方法也要进行keep</span><span class="token attr-name">-keepclassmembers</span> <span class="token attr-value">class com.example.xxx.JSInterface{</span>    &lt;methods>;}</code></pre><h5 id="针对反射的处理"><a href="#针对反射的处理" class="headerlink" title="针对反射的处理"></a>针对反射的处理</h5><p>在程序中使用SomeClass.class.method这样的静态方法，在ProGuard中是在压缩过程中被保留的，那么对于Class.forName(“SomeClass”)呢，SomeClass不会被压缩过程中移除，它会检查程序中使用的Class.forName方法，对参数SomeClass法外开恩，不会被移除。但是在混淆过程中，无论是Class.forName(“SomeClass”)，还是SomeClass.class，都不能蒙混过关，SomeClass这个类名称会被混淆，因此，我们要在ProGuard.cfg文件中保留这个类名称。<br>Class.forName(“SomeClass”)<br>SomeClass.class<br>SomeClass.class.getField(“someField”)<br>SomeClass.class.getDeclaredField(“someField”)<br>SomeClass.class.getMethod(“someMethod”, new Class[] {})<br>SomeClass.class.getMethod(“someMethod”, new Class[] { A.class })<br>SomeClass.class.getMethod(“someMethod”, new Class[] { A.class, B.class })<br>SomeClass.class.getDeclaredMethod(“someMethod”, new Class[] {})<br>SomeClass.class.getDeclaredMethod(“someMethod”, new Class[] { A.class })<br>SomeClass.class.getDeclaredMethod(“someMethod”, new Class[] { A.class, B.class })<br>AtomicIntegerFieldUpdater.newUpdater(SomeClass.class, “someField”)<br>AtomicLongFieldUpdater.newUpdater(SomeClass.class, “someField”)<br>AtomicReferenceFieldUpdater.newUpdater(SomeClass.class, SomeType.class, “someField”)<br>在混淆的时候，要在项目中搜索一下上述方法，将相应的类或者方法的名称进行保留而不被混淆。</p><h5 id="第三方开发库的混淆"><a href="#第三方开发库的混淆" class="headerlink" title="第三方开发库的混淆"></a>第三方开发库的混淆</h5><p>一般情况第三方的开发库都会提供混淆的配置，如果没有，可以使用下面类似的模板</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true"># 针对android-support-v4.jar的解决方案,可以按照此模板进行修改</span><span class="token comment" spellcheck="true">#不是每个第三方SDK都需要-dontwarn 指令，这取决于混淆时第三方SDK是否出现警告，需要的时候再加上。</span><span class="token attr-name">-libraryjars</span> <span class="token attr-value">libs/android-support-v4.jar</span><span class="token attr-name">-dontwarn</span> <span class="token attr-value">android.support.v4.**</span><span class="token attr-name">-keep</span> <span class="token attr-value">class android.support.v4.**  { *; }</span><span class="token attr-name">-keep</span> <span class="token attr-value">interface android.support.v4.app.** { *; }</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class * extends android.support.v4.**</span><span class="token attr-name">-keep</span> <span class="token attr-value">public class * extends android.app.Fragment</span></code></pre><p>对于自定义类库的混淆处理,比如我们引用了一个叫做AndroidLib的类库，我们需要对Lib也进行混淆，然后在主项目的混淆文件中保留AndroidLib中的类和类的成员。</p><h5 id="Anroid-官方建议-不混淆的，如"><a href="#Anroid-官方建议-不混淆的，如" class="headerlink" title="Anroid 官方建议 不混淆的，如"></a>Anroid 官方建议 不混淆的，如</h5><pre class=" language-properties"><code class="language-properties">android.app.backup.BackupAgentHelperandroid.preference.Preferencecom.android.vending.licensing.ILicensingService</code></pre><h5 id="使用annotation避免混淆"><a href="#使用annotation避免混淆" class="headerlink" title="使用annotation避免混淆"></a>使用annotation避免混淆</h5><p>@keep<br>@keepPublicGetterSetters<br>public class DemoBean{<br>    public  boolean booleanProperty;<br>    public  int intProperty;<br>    public  String stringProperty;<br>}</p><h5 id="对于Kotlin的支持"><a href="#对于Kotlin的支持" class="headerlink" title="对于Kotlin的支持"></a>对于Kotlin的支持</h5><p>目前Progurad对kotlin的支持版本还是beta版本</p><pre class=" language-properties"><code class="language-properties"><span class="token comment" spellcheck="true">#针对kotlin代码混淆的keep内容</span><span class="token attr-name">-keep</span> <span class="token attr-value">class kotlin.** { *; }</span><span class="token attr-name">-keep</span> <span class="token attr-value">class kotlin.Metadata { *; }</span><span class="token attr-name">-dontwarn</span> <span class="token attr-value">kotlin.**</span><span class="token comment" spellcheck="true">#maping 枚举方法需要keep</span><span class="token attr-name">-keepclassmembers</span> <span class="token attr-value">class **$WhenMappings {</span>    &lt;fields>;}<span class="token comment" spellcheck="true">#针对metadata元数据的public方法</span><span class="token attr-name">-keepclassmembers</span> <span class="token attr-value">class kotlin.Metadata {</span><span class="token attr-name">    public</span> <span class="token attr-value">&lt;methods>;</span>}<span class="token comment" spellcheck="true">#针对checkParameterIsNotNull这个方法</span><span class="token attr-name">-assumenosideeffects</span> <span class="token attr-value">class kotlin.jvm.internal.Intrinsics {</span><span class="token attr-name">    static</span> <span class="token attr-value">void checkParameterIsNotNull(java.lang.Object, java.lang.String);</span>}</code></pre><h5 id="最后要说的一点"><a href="#最后要说的一点" class="headerlink" title="最后要说的一点"></a>最后要说的一点</h5><p>因为现在的R8,我找到了一些新功能,比如支持java内联替换功能,但是我测试没有成功,如果哪位有测试成功了,请与我分享一下.非常感谢.个人认为R8的内联功能还是非常实用的,能够实现很多有趣的玩法.最后感谢大家.</p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> 混淆 </tag>
            
            <tag> R8 </tag>
            
            <tag> 优化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何调试已经加壳的APK文件</title>
      <link href="/2019/12/11/debug-apk/"/>
      <url>/2019/12/11/debug-apk/</url>
      
        <content type="html"><![CDATA[<p>今天有个任务,让我去调试一个APK,需要查看它的性能参数,内存/CPU等的占用,第一时间拿出工具准备反编译,但是发现此包使用了360加固,不确定是否有签名校验,如果有,我就没办法修改AndroidManifest.xml文件来打开调试了.</p><p>既然改包的方法不行,那就只能在系统层面想办法了,谁让我有root的手机呢.</p><p>一下操作需要root权限,如果没有的,请先root手机获取权限</p><p>打开手机的Re文件管理器,找到系统的/目录</p><p>如图,RE文件管理器</p><p><img src="https://zhanweisun.github.io/image/launchicon.png?raw=true" alt=""></p><p>打开系统的根目录 / ,选择default.prop文件</p><p><img src="https://zhanweisun.github.io/image/file.png?raw=true" alt=""></p><p>选择右上角的菜单,找到打开方式</p><p><img src="https://zhanweisun.github.io/image/openmenu.png?raw=true" alt=""></p><p>使用”以文本方式编辑”打开</p><p><img src="https://zhanweisun.github.io/image/opentype.jpg?raw=true" alt=""></p><p>把ro.secure 和ro.debuggable 字段都改成1,然后重启你的手机</p><p><img src="https://zhanweisun.github.io/image/edit.png?raw=true" alt=""></p><p>完毕以后就可以用数据线链接手机,进行性能测试了</p><p>如下图</p><p><img src="https://zhanweisun.github.io/image/run.jpg?raw=true" alt=""></p><p><img src="https://zhanweisun.github.io/image/cpu&mem.jpg?raw=true" alt=""></p>]]></content>
      
      
      
        <tags>
            
            <tag> android </tag>
            
            <tag> apk </tag>
            
            <tag> 调试 </tag>
            
            <tag> root </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记录一些开发中的琐碎</title>
      <link href="/2019/12/09/tips/"/>
      <url>/2019/12/09/tips/</url>
      
        <content type="html"><![CDATA[<h5 id="1-ubuntu-安装gimp之后没有中文"><a href="#1-ubuntu-安装gimp之后没有中文" class="headerlink" title="1.ubuntu 安装gimp之后没有中文"></a>1.ubuntu 安装gimp之后没有中文</h5><p>一般出现在kubuntu上面,只要安装一下language-pack-gnome-zh-hant就可以了</p><pre><code>sudo apt-get install language-pack-gnome-zh-hant</code></pre><h5 id="2-IDA在64位ubuntu上面提示error-while-loading-shared-libraries-libgtk-x11-2-0-so-0-cannot-open-shared-object-file"><a href="#2-IDA在64位ubuntu上面提示error-while-loading-shared-libraries-libgtk-x11-2-0-so-0-cannot-open-shared-object-file" class="headerlink" title="2.IDA在64位ubuntu上面提示error while loading shared libraries: libgtk-x11-2.0.so.0: cannot open shared object file"></a>2.IDA在64位ubuntu上面提示error while loading shared libraries: libgtk-x11-2.0.so.0: cannot open shared object file</h5><p>这个问题主要是因为缺少开发库,虽然ida是64位的,但是还是有32位依赖库的东西,所以我们要安装一下32位的东西你,命令如下</p><pre class=" language-shell"><code class="language-shell">sudo apt-get install libgtk2.0-0:i386 libxxf86vm1:i386 libsm6:i386 lib32stdc++6</code></pre><h5 id="3-mac-系统中很多软件是32位的-但是10-15以后系统不允许运行了"><a href="#3-mac-系统中很多软件是32位的-但是10-15以后系统不允许运行了" class="headerlink" title="3.mac 系统中很多软件是32位的,但是10.15以后系统不允许运行了"></a>3.mac 系统中很多软件是32位的,但是10.15以后系统不允许运行了</h5><p>解决办法如下</p><pre class=" language-shell"><code class="language-shell">sudo spctl --master-disable</code></pre><h5 id="4-编译elfutils"><a href="#4-编译elfutils" class="headerlink" title="4.编译elfutils"></a>4.编译elfutils</h5><pre class=" language-shell"><code class="language-shell">autoheaderaclocal -I m4autoconfautomake -a -c./configuremake</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 小技巧 </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 编译edb debugger</title>
      <link href="/2019/12/06/edb-debugger/"/>
      <url>/2019/12/06/edb-debugger/</url>
      
        <content type="html"><![CDATA[<h3 id="Ubuntu-编译edb-debugger"><a href="#Ubuntu-编译edb-debugger" class="headerlink" title="Ubuntu 编译edb debugger"></a>Ubuntu 编译edb debugger</h3><h4 id="1-首先安装第三方库"><a href="#1-首先安装第三方库" class="headerlink" title="1.首先安装第三方库"></a>1.首先安装第三方库</h4><pre class=" language-shell"><code class="language-shell">sudo apt-get install         cmake                                  \    build-essential        \    libboost-dev           \    libqt5xmlpatterns5-dev \    qtbase5-dev            \    qt5-default            \    libqt5svg5-dev         \    libgraphviz-dev        \    libcapstone-dev        \    pkg-config</code></pre><h4 id="2-获取edb-debugger源代码"><a href="#2-获取edb-debugger源代码" class="headerlink" title="2.获取edb-debugger源代码"></a>2.获取edb-debugger源代码</h4><pre class=" language-shell"><code class="language-shell">git clone --recursive https://github.com/eteran/edb-debugger.git</code></pre><h4 id="3-编译源代码"><a href="#3-编译源代码" class="headerlink" title="3.编译源代码"></a>3.编译源代码</h4><pre class=" language-shell"><code class="language-shell">cd edb-debuggermkdir buildcd buildcmake ..make -j8  //-j可以根据自己cpu的数量修改//最后需要安装到系统,可以执行,默认安装位置/usr/local/lib/edb/sudo make install</code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 调试器 </tag>
            
            <tag> edb </tag>
            
            <tag> debugger </tag>
            
            <tag> debug </tag>
            
            <tag> OllyDbg </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Go 语言学习之文件操作</title>
      <link href="/2017/04/11/go-file-op/"/>
      <url>/2017/04/11/go-file-op/</url>
      
        <content type="html"><![CDATA[<h3 id="2017年2月27日"><a href="#2017年2月27日" class="headerlink" title="2017年2月27日"></a>2017年2月27日</h3><blockquote><p>文件操作在编程中是非常重要的,我们经常操作的文件类型一般分为二进制文件和普通文本文件,因为文本文件与二进制文件的区别仅仅是编码上不同，所以他们的优缺点就是编码的优缺点.今天我们来学习一下如何用Go语言来建立和操作文件.</p></blockquote><ul><li>1.建立文件</li></ul><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token string">"os"</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    customFile<span class="token operator">:=</span><span class="token string">"customFile.dat"</span>    file<span class="token punctuation">,</span>err<span class="token operator">:=</span>os<span class="token punctuation">.</span><span class="token function">Create</span><span class="token punctuation">(</span>customFile<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//创建文件</span>    <span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">checkErr</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    file<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">"Hello world"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//使用Write写入数据.这里接受的是byte数组</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">checkErr</span><span class="token punctuation">(</span>err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><ul><li>2.打开文件</li></ul><pre class=" language-go"><code class="language-go"><span class="token keyword">package</span> main<span class="token keyword">import</span> <span class="token punctuation">(</span>    <span class="token string">"os"</span>    <span class="token string">"fmt"</span><span class="token punctuation">)</span><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    customFile<span class="token operator">:=</span><span class="token string">"customFile.dat"</span>    file<span class="token punctuation">,</span>err<span class="token operator">:=</span>os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>customFile<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//打开文件</span>    <span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token function">checkErr</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    fileSize<span class="token punctuation">,</span>err<span class="token operator">:=</span>os<span class="token punctuation">.</span><span class="token function">Stat</span><span class="token punctuation">(</span>customFile<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//获取文件大小,用来开辟读取的空间</span>    <span class="token function">checkErr</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    data<span class="token operator">:=</span><span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span><span class="token function">int</span><span class="token punctuation">(</span>fileSize<span class="token punctuation">.</span><span class="token function">Size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//申请用来保存数据的空间</span>    file<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//读取数据</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//打印数组数据</span>    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">//打印字符串数据</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">checkErr</span><span class="token punctuation">(</span>err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">{</span>        <span class="token function">panic</span><span class="token punctuation">(</span>err<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> go </tag>
            
            <tag> 文件操作s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>教你如何将公交卡和手机合二为一</title>
      <link href="/2017/02/27/phone-card/"/>
      <url>/2017/02/27/phone-card/</url>
      
        <content type="html"><![CDATA[<h3 id="2017年2月23日"><a href="#2017年2月23日" class="headerlink" title="2017年2月23日"></a>2017年2月23日</h3><blockquote><p>平时我们经常会做公交或者地铁,刷卡是不可避免的,但是人多的时候,拿卡不方便,又是手机,又是包包,一堆东西很容易弄丢.为了方便,我今天教大家改造自己的手机,把公交卡装进手机.</p></blockquote><p>今天的方法有两种,一种推荐给动手能力强的同学,一种推荐给觉得麻烦的同学.</p><ul><li>1.第一种方法,操作比较复杂,需要我们有工具,并且有一定的动手能力,推荐喜欢折腾的同学.孙老师我就为了折腾这个,损坏了两张公交卡呢.不过没事,我是土豪,哈哈哈</li></ul><p>首先,我们平时用的公交卡,如下图<br><img src="https://zhanweisun.github.io/image/card.png?raw=true" alt=""></p><p>黑色记号笔所标记的地方是我们的公交卡芯片所在的位置,我们需要使用手电筒,照在卡的背面,沿着边缘里面一点一点的找,很快就能找到芯片所在的位置.</p><p>找到芯片的位置以后,我们需要的就是使用剪刀一类的工具,把芯片剪下来,记得多剪一些,防止损坏芯片.<br><img src="https://github.com/zhanweisun/zhanweisun.github.io/blob/master/image/card2.png?raw=true" alt=""></p><p>剪下来的芯片因为还是被塑料包裹着,依然不方便取出,这个时候,我们可以从万能的X宝买一些溶解塑料的溶解液,把芯片放进去,过几个小时就能溶解塑料,轻松获取芯片了.如果觉得动手能力很强,可以完整的用刀片取出,那也可以.不过祝你成功,骚年.<br><img src="https://zhanweisun.github.io/image/card3.png?raw=true" alt=""></p><p>拿到了芯片,接下来,我们要给芯片安装线圈了.首先还是要万能的X宝,有现成的可以买,当然你要是自己做,我也不拦着,主要是要各种试验,比较麻烦,而且容易损坏芯片.</p><p>有了线圈,就可以将芯片两端的金属和芯片进行焊接操作,不过千万要小心,芯片不耐热,烙铁要是在芯片上太久了,会损坏芯片的.</p><p>焊完的样子大概是这个样子的<br><img src="https://zhanweisun.github.io/image/card4.png?raw=true" alt=""></p><p>最后,还是X宝,买一个抗干扰防磁贴,贴在手机的背面,然后在把我们刚才焊接的芯片贴在磁贴的前面,外面再套上手机套,就可以完成了.</p><p><img src="https://zhanweisun.github.io/image/card5.png?raw=true" alt=""></p><p>这样做的好处就是手机和公交卡直接放在一起,坐车的时候直接刷一下手机就行了,虽然我的红米没有nfc,但是这样之后,我仍然可以冒充我有nfc,嘿嘿.</p><p>第一种方法的好处是整个手机的厚度基本不会增加,而且刷卡灵敏度也很好,但是动手操作的地方比较多,而且要小心,否则很容易损坏芯片,别问我怎么知道的(我已经损坏了两张卡了).</p><ul><li>2.第二种方法比较简单但是对手机的大小有要求,你的手机必须要大一些,这样能在手机壳下面装的下你的卡.推荐大家使用硅胶手机套,因为这个套套有弹性,手感好,还耐磨,耐磨,耐磨……嘿嘿嘿嘿</li></ul><p>首先拿出我们的卡,比较一下跟手机的大小,最好手机比我们的卡大上两圈.这样放进去更容易</p><p><img src="https://zhanweisun.github.io/image/phone001.jpg?raw=true" alt=""></p><p>下面是我们的卡和手机套对比.看看我们的卡是否能安装在手机和手机套之间.推荐最好选择硅胶套,有弹性,方便安装,而且外表不变形.</p><p><img src="https://zhanweisun.github.io/image/phone002.jpg?raw=true" alt=""></p><p>放入手机壳内,看看是否合适.</p><p><img src="https://zhanweisun.github.io/image/phone003.jpg?raw=true" alt=""></p><p>接下来,把我们从淘宝买的磁贴贴在我们的卡背面,然后磁贴这边贴着手机这面,我们的卡贴着硅胶套这面,然后放入我们的手机.</p><p><img src="https://zhanweisun.github.io/image/phone004.jpg?raw=true" alt=""></p><p>最后成功的样子!</p><p><img src="https://zhanweisun.github.io/image/phone005.jpg?raw=true" alt=""></p><p>总结:</p><p>两种方法都是可行的,我已经试过了.</p><p>那么第一种好出就是如果你的手机支持背壳可拆卸,你甚至可以把这个放在手机内部,但是操作麻烦,各种拆拆拆.动手能力差的同学不推荐.</p><p>第二个种的好出就是非常简单,适合动手能力弱的同学,但是第二种一般不适合喜欢裸奔的同学,需要手机套配合使用.</p><p>以上两种方法都可以让你实现公交卡和手机结合,让你的手机没有全NFC功能也一样可以刷公交卡,里面提到的一些东西,X宝都可以买到,价格便宜,动手改造一下自己的手机,方便生活.<br>谢谢大家,我是孙老师.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 手机 </tag>
            
            <tag> 公交卡 </tag>
            
            <tag> nfc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>开博</title>
      <link href="/2017/02/22/hello-world/"/>
      <url>/2017/02/22/hello-world/</url>
      
        <content type="html"><![CDATA[<h3 id="2017年2月22日"><a href="#2017年2月22日" class="headerlink" title="2017年2月22日"></a>2017年2月22日</h3><p>博客开始创立<br>欢迎大家访问</p>]]></content>
      
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
